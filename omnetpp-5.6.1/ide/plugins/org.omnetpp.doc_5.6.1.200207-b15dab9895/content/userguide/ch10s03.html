<html><head><link rel="STYLESHEET" href="../book.css"  type="text/css"/><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Using the Analysis Editor</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="OMNeT&#8288;+&#8288;+ User Guide"><link rel="up" href="ch10.html" title="Chapter 10. Analyzing the Results"><link rel="prev" href="ch10s02.html" title="Creating Analysis Files"><link rel="next" href="ch10s04.html" title="Associated Views"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Using the Analysis Editor</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch10s02.html">Prev</a> </td><th width="60%" align="center">Chapter 10. Analyzing the Results</th><td width="20%" align="right"> <a accesskey="n" href="ch10s04.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm4284"></a>Using the Analysis Editor</h2></div></div></div><p> The Analysis Editor is implemented as a multi-page editor. What the editor edits is the "recipe":
      what result files to take as inputs, what data to select from them, what (optional) processing steps to
      apply, and what kind of charts to create from them. The pages (tabs) of the editor roughly correspond to
      these steps.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4287"></a>Input Files</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4289"></a>Selecting input files</h4></div></div></div><p> The first page displays the result files that serve as input for the analysis. The upper half
          specifies what files to select using explicit filenames or wildcards. New input files can be added
          to the analysis by dragging vector and scalar files from the <span class="emphasis"><em>Project Explorer View</em></span>, or by
          opening dialogs with the <span class="emphasis"><em>Add File...</em></span> or <span class="emphasis"><em>Wildcard...</em></span> buttons. If the file name starts with
          '/,' it is interpreted relative to the workspace root; otherwise, it is relative to the folder of the
          analysis file.</p><div class="figure"><a name="pictures/ANF-InputsPage.png"></a><p class="title"><b>Figure 10.2.  Specifying input files for data analysis</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-InputsPage.png" align="middle" alt="Specifying input files for data analysis"></div></div></div></div><br class="figure-break"><p> The input files are loaded when the analysis file is opened. When the file changes on the disk,
          it is reloaded automatically when the workspace is refreshed (Eclipse refreshes the workspace
          automatically if the <span class="emphasis"><em>General|Workspace|Refresh automatically</em></span> option is turned on in the
          Preferences). Vector files are not loaded directly; instead, an index file is created and the vector
          attributes (name, module, run, statistics, etc.) are loaded from the index file. The index files are
          generated during the simulation, but can be safely deleted without loss of information. If the index
          file is missing or the vector file was modified, the IDE rebuilds the index in the background.
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p> The <span class="emphasis"><em>Progress View</em></span> displays the progress of the indexing process.</p></div><p>
          The lower half shows what files matched the input specification and what runs they
          contain. Note that OMNeT&#8288;+&#8288;+
          4.x result files contain a unique run ID and several metadata annotations in addition to the actual
          recorded data. The third tree organizes simulation runs according to their
          experiment-measurement-replication labels.
        </p><p>
          The underlying assumption is that users will organize their simulation-based research into various
          <span class="emphasis"><em>experiments</em></span>. An experiment will consist of several
          <span class="emphasis"><em>measurements</em></span>,
          which are typically (but not necessarily) simulations done with the same model but with different
          parameter settings (i.e. the user will explore the parameter space with several simulation runs).
          To gain statistical confidence in the results, each measurement may be repeated
          several times with different random number seeds. It is easy to set up such scenarios with the
          improved INI files of OMNeT&#8288;+&#8288;+
          4.x. Then, the experiment-measurement-replication labels will be assigned automatically (Note: please
          refer to the chapter "Configuring and Running Simulations" in the manual for more discussion).
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4312"></a>Browsing input</h4></div></div></div><p> The second page of the Analysis editor displays results (vectors, scalars and histograms) from
          all files in tables and lets the user browse them. Results can be sorted and filtered. Simple
          filtering is possible with combo boxes, or when that is not enough, the user can write arbitrarily
          complex filters using a generic pattern-matching expression language. Selected or filtered data can
          be immediately plotted, or remembered in named datasets for further processing.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3>You can switch between the <span class="emphasis"><em>All</em></span>, <span class="emphasis"><em>Vectors</em></span>, <span class="emphasis"><em>Scalars</em></span> and <span class="emphasis"><em>Histograms</em></span> pages using the 
            underlined keys (<span class="keycap"><strong>Alt+KEY</strong></span> combination) or the <span class="keycap"><strong>Ctrl+PgUp</strong></span> and 
            <span class="keycap"><strong>Ctrl+PgDown</strong></span> keys.</div><p> Pressing the <span class="emphasis"><em>Advanced</em></span> button switches to advanced filter mode. In the text field, you can
          enter a complex filter pattern.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p> You can easily display the data of a selected file, run, experiment, measurement or
            replication if you double-click on the required tree node in the lower part of the <span class="emphasis"><em>Inputs</em></span> page. It
            sets the appropriate filter and shows the data on the <span class="emphasis"><em>Browse Data</em></span> page.</p><p> If you right-click on a table cell and select the <span class="emphasis"><em>Set filter: ...</em></span> action from the menu, you
            can set the value of that cell as the filter expression.</p></div><div class="figure"><a name="pictures/ANF-BrowseDataPage.png"></a><p class="title"><b>Figure 10.3.  Browsing vector and scalar data generated by the simulation</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-BrowseDataPage.png" align="middle" alt="Browsing vector and scalar data generated by the simulation"></div></div></div></div><br class="figure-break"><p> To hide or show table columns, open <span class="emphasis"><em>Choose table columns...</em></span> from the context menu and
          select the columns to be displayed. The settings are persistent and applied in each subsequently
          opened editor. The table rows can be sorted by clicking on the column name.</p><p> You can display the selected data items on a chart. To open the chart, choose <span class="emphasis"><em>Plot</em></span> from the
          context menu (double-click also works for single data lines). The opened chart is not added
          automatically to the analysis file, so you can explore the data by opening the chart this way and
          closing the chart page without making the editor "dirty."</p><p> The selected vector's data can also be displayed in a table. Make sure that the <span class="emphasis"><em>Output Vector
          View</em></span> is opened. If it is not open, you can open it from the context menu (<span class="emphasis"><em>Show Output Vector View</em></span>).
          If you select a vector in the editor, the view will display its content.</p><p> You can create a dataset from the selected result items. Select <span class="emphasis"><em>Add Filter Expression to
          Dataset...</em></span> if you want to add all items displayed in the table. Select <span class="emphasis"><em>Add Filter Selected Data
          to Dataset...</em></span> if you want to add the selected items only. You can add the items to an existing
          dataset, or you can create a new dataset in the opening dialog.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3>You can switch between the <span class="emphasis"><em>Inputs</em></span>, <span class="emphasis"><em>Browse Data</em></span> and <span class="emphasis"><em>Dataset</em></span> pages using the 
            <span class="keycap"><strong>Alt+PgUp</strong></span> and <span class="keycap"><strong>Alt+PgDown</strong></span> keys.</div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4355"></a>Filter expressions</h4></div></div></div><p>
          A filter expression is composed of atomic patterns with the AND, OR, NOT operators. An atomic
          pattern filters for the value of a field of the result item and has the form &lt;field_name&gt;(&lt;pattern&gt;).
          The following table shows the valid field names. You can omit the name field and simply use the name
          pattern as a filter expression. It must be quoted if it contains whitespace or
          parentheses.
          </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>name</td><td>the name of the scalar, vector or histogram</td></tr><tr><td>module</td><td>the name of the module</td></tr><tr><td>file</td><td>the file of the result item</td></tr><tr><td>run</td><td>the run identifier</td></tr><tr><td>attr: <span class="emphasis"><em>name</em></span></td><td>the value of the run attribute named <span class="emphasis"><em>name</em></span>, e.g. attr:experiment</td></tr><tr><td>param: <span class="emphasis"><em>name</em></span></td><td>the value of the module parameter named <span class="emphasis"><em>name</em></span></td></tr></tbody></table></div><p>
          In the pattern specifying the field value, you can use the following shortcuts:
          </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Pattern</th><th>Description</th></tr></thead><tbody><tr><td>?</td><td>matches any character except '.'</td></tr><tr><td>*</td><td>matches zero or more characters except '.'</td></tr><tr><td>**</td><td>matches zero or more characters (any character)</td></tr><tr><td>{a-z}</td><td>matches a character in range a-z</td></tr><tr><td>{^a-z}</td><td>matches a character not in range a-z</td></tr><tr><td>{32..255}</td><td>any number (i.e. sequence of digits) in range 32..255 (e.g. "99")</td></tr><tr><td>[32..255]</td><td>any number in square brackets in range 32..255 (e.g. "[99]")</td></tr><tr><td>\</td><td>takes away the special meaning of the subsequent character</td></tr></tbody></table></div><p>
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
            Content Assist is available in the text fields where you can enter a filter expression. Press
            <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Space</strong></span>
            to get a list of appropriate suggestions related to the expression at the cursor position.
          </p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4427"></a>Examples</h4></div></div></div><div class="informalexample"><p>
            </p><div class="literallayout"><p><strong class="userinput"><code>"queuing time"</code></strong></p></div><p>
          </p><p>
            filters for result items named <span class="emphasis"><em>queuing time</em></span>.
          </p></div><div class="informalexample"><p>
            </p><div class="literallayout"><p><strong class="userinput"><code>module(**.sink) AND (name("queuing time") OR</code></strong><br>
<strong class="userinput"><code>                     name("transmission time"))</code></strong></p></div><p>
          </p><p>
            results in the <span class="emphasis"><em>queuing times</em></span> and <span class="emphasis"><em>transmission times</em></span> that are written by modules named <span class="emphasis"><em>sink</em></span>.
          </p></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4444"></a>Datasets</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4446"></a>Overview</h4></div></div></div><p> The third page displays the datasets and charts created during the analysis. Datasets describe
          a set of input data, the processing applied to them and the charts. The dataset is displayed as a
          tree of processing steps and charts. There are nodes for adding and discarding data, applying
          processing to vectors and scalars, selecting the operands of the operations and content of charts,
          and for creating charts.</p><div class="figure"><a name="pictures/ANF-DatasetsPage.png"></a><p class="title"><b>Figure 10.4. Defining datasets to be analyzed</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-DatasetsPage.png" align="middle" alt="Defining datasets to be analyzed"></div></div></div></div><br class="figure-break"><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p> You can browse the dataset's content in the <span class="emphasis"><em>Dataset View</em></span>. Open the view by selecting
            <span class="emphasis"><em>Show Dataset View</em></span> from the context menu. Select a chart to display its content or another node
            to display the content of the dataset after processing is applied.</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4461"></a>Editing datasets</h4></div></div></div><p> The usual tree editing operations work on the Dataset tree. New elements can be added by
          dragging elements from the palette on the right to an appropriate place on the tree. Alternatively,
          you can select the parent node and press the button on the toolbar. An existing element can be
          edited by selecting the element and editing its properties on the property sheet, or by opening an
          item-specific edit dialog by choosing <span class="emphasis"><em>Properties...</em></span> from the context menu.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p> Datasets can be opened on a separate page by double-clicking on them. It is easier
            to edit the tree on this page. Double-clicking a chart node will display the chart.</p></div><p>
          Computations can be applied to the data by adding Apply to Vectors/Compute Vectors/Compute Scalars
          nodes to the dataset. The input of the computations can be selected by adding Select/Deselect children to the
          processing node. By default, the computation input is the whole content of the dataset at the processing node.
          Details of the computations are described in the next sections.
        </p><p> Processing steps within a Group node only affect the group. This way, you can
          create branches in the dataset. To group a range of sibling nodes, select them and choose <span class="emphasis"><em>Group</em></span>
          from the context menu. To remove the grouping, select the Group node and choose <span class="emphasis"><em>Ungroup</em></span>.</p><p>
          Charts can be inserted to display data. The data items to be displayed can be selected by adding
          Select/Deselect children to the chart node. By default, the chart displays all data in the dataset at
          its position. You can modify the content of the chart by adding Select and Deselect children to it.
          Charts can be fully customized including setting titles, colors, adding legends, grid lines, etc.
          See the
          <a class="xref" href="ch10s03.html#charts" title="Charts">Charts</a>
          section for details.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4473"></a>Computing Vectors</h4></div></div></div><p>
          Both Compute Vectors and Apply to Vectors nodes compute new vectors from other vectors.
          The difference between them is that Apply to Vectors will remove
          its input from the dataset, while Compute keeps the original data, too.
        </p><p>
          <a class="xref" href="ch10s03.html#processing-operations" title="Table 10.1. Processing operations">Table 10.1, &#8220;Processing operations&#8221;</a> contains the list of available operations on vectors.
          </p><div class="table"><a name="processing-operations"></a><p class="title"><b>Table 10.1. Processing operations</b></p><div class="table-contents"><table class="table" summary="Processing operations" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>scatter</td><td>Create scatter plot dataset. The first two arguments identifies the scalar selected for the X axis. Additional arguments identify the iso attributes; they are (module, scalar) pairs, or names of run attributes.</td></tr><tr><td>add</td><td>Adds a constant to the input: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = y<sub>k</sub> + c</em></span></td></tr><tr><td>compare</td><td>Compares value against a threshold, and optionally replaces it with a constant</td></tr><tr><td>crop</td><td>Discards values outside the [t1, t2] interval</td></tr><tr><td>difference</td><td>Substracts the previous value from every value: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = y<sub>k</sub> - y<sub>k-1</sub></em></span></td></tr><tr><td>diffquot</td><td>Calculates the difference quotient of every value and the subsequent one: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = (y<sub>k+1</sub>-y<sub>k</sub>) / (t<sub>k+1</sub>-t<sub>k</sub>)</em></span></td></tr><tr><td>divide-by</td><td>Divides input by a constant: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = y<sub>k</sub> / a</em></span></td></tr><tr><td>divtime</td><td>Divides input by the current time: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = y<sub>k</sub> / t<sub>k</sub></em></span></td></tr><tr><td>expression</td><td>Evaluates an arbitrary expression. Use t for time, y for value, and tprev, yprev for the previous values.</td></tr><tr><td>integrate</td><td>Integrates the input as a step function (sample-hold or backward-sample-hold) or with linear interpolation</td></tr><tr><td>lineartrend</td><td>Adds linear component to input series: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = y<sub>k</sub> + a * t<sub>k</sub></em></span></td></tr><tr><td>mean</td><td>Calculates mean on (0,t)</td></tr><tr><td>modulo</td><td>Computes input modulo a constant: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = y<sub>k</sub> % a</em></span></td></tr><tr><td>movingavg</td><td>Applies the exponentially weighted moving average filter: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = y<sup>out</sup><sub>k-1</sub> + alpha*(y<sub>k</sub>-y<sup>out</sup><sub>k-1</sub>)</em></span></td></tr><tr><td>multiply-by</td><td>Multiplies input by a constant: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = a * y<sub>k</sub></em></span></td></tr><tr><td>nop</td><td>Does nothing</td></tr><tr><td>removerepeats</td><td>Removes repeated y values</td></tr><tr><td>slidingwinavg</td><td>Replaces every value with the mean of values in the window: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = SUM(y<sub>i</sub>,i=k-winsize+1..k)/winsize</em></span></td></tr><tr><td>subtractfirstval</td><td>Subtract the first value from every subsequent values: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = y<sub>k</sub> - y[0]</em></span></td></tr><tr><td>sum</td><td>Sums up values: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = SUM(y<sub>i</sub>, i=0..k)</em></span></td></tr><tr><td>timeavg</td><td>Calculates the time average of the input (integral divided by time)</td></tr><tr><td>timediff</td><td>Returns the difference in time between this and the previous value: <span class="emphasis"><em>y<sup>out</sup><sub>k</sub> = t<sub>k</sub> - t<sub>k-1</sub></em></span></td></tr><tr><td>timeshift</td><td>Shifts the input series in time by a constant: <span class="emphasis"><em>t<sup>out</sup><sub>k</sub> = t<sub>k</sub> + dt</em></span></td></tr><tr><td>timetoserial</td><td>Replaces time values with their index: <span class="emphasis"><em>t<sup>out</sup><sub>k</sub> = k</em></span></td></tr><tr><td>timewinavg</td><td>Calculates time average: replaces input values in every `windowSize' interval with their mean. <span class="emphasis"><em>t<sup>out</sup><sub>k</sub> = k * winSize y<sup>out</sup><sub>k</sub> = average of y values in the [(k-1)*winSize, k*winSize) interval</em></span></td></tr><tr><td>winavg</td><td>Calculates batched average: replaces every `winsize' input values with their mean. Time is the time of the first value in the batch.</td></tr></tbody></table></div></div><p><br class="table-break">
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4641"></a>Computing Scalars</h4></div></div></div><p>The Compute Scalars dataset node adds new scalars to the dataset whose values are computed
        from other statistics in the dataset. The input of the computation can be restricted by adding
        Select/Deselect nodes under it.</p><div class="figure"><a name="pictures/ANF-EditComputeScalars.png"></a><p class="title"><b>Figure 10.5. Edit 'Compute Scalars' dialog</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="80%"><tr><td align="center"><img src="pictures/ANF-EditComputeScalars.png" align="middle" width="100%" alt="Edit 'Compute Scalars' dialog"></td></tr></table></div></div></div></div><br class="figure-break"><p>In the <span class="emphasis"><em>Properties</em></span> dialog of the Compute Scalars node, you can set the name and module of the generated
        scalars, and the expression that computes their values. You can also can enter a grouping expression,
        and set flags to average the values across replications.
        Content Assist (<span class="keycap"><strong>Ctrl+SPACE</strong></span>) is available for the <span class="emphasis"><em>Value</em></span> field, it can
        propose statistic and function names.</p><p>The content of the dialog is validated after each keystroke, and errors are displayed as small
        icons next to the edit field. Hovering over the error icon shows the error message. However, not all errors
        can be detected statically, in the dialog. If an error occurs while performing the computation, then an error
        marker is added to the analysis file and to the corresponding dataset node in the Analysis editor.
        You can view the error in the <span class="emphasis"><em>Problems View</em></span>, and double-clicking the problem item navigates back to the
        <span class="emphasis"><em>Compute Scalars</em></span> node.</p><p>When a <span class="emphasis"><em>Compute Scalars</em></span> node in the dataset is evaluated,
        computations will use the fields rougly in the order they appear in the dialog.
        First, grouping takes place (by simulation run, and then by the optional grouping expression);
        then values are computed; then values are stored by the given name and module; and finally,
        averaging across simulation runs takes place.</p><p>Explanation the dialog fields:</p><p><b>Value. </b>
        This is an arithmetic expression for the value of the generated scalar(s). You can use
        the values of existing scalars, various properties of existing vectors and histograms
        (mean, min, max, etc), normal and aggregate functions (mean, min, max, etc),
        and the usual set of operators.</p><p>To refer to the value of a scalar, simply use the scalar name (e.g. <code class="literal">pkLoss</code>),
        or enclose it with apostrophes if the name of the scalar contains special characters
        (e.g. <code class="literal">'rcvdPk:count'</code>.) If there are several scalars with that name in the
        input dataset, usually recorded by different modules or in different runs, then the computation
        will be performed on each. The scalar name cannot contain wildcards or dollar variables (see later.)</p><p>When necessary, you can qualify the scalar name with a module name pattern that will be
        matched against the full paths of modules. The same pattern syntax is used as in ini files and
        in other parts of the Analysis Tool (Quick reminder: use <code class="literal">*</code> and <code class="literal">**</code> for wildcards, <code class="literal">{5..10}</code>
        for numeric range, <code class="literal">[5..10</code>] for module index range). If multiple scalars match
        the qualified name, the expression will be computed for each. If there are several such patterns
        in the expression, then the computation will be performed on their Cartesian product.</p><p>If the expression mentions several unqualified scalars (i.e. without module pattern),
        they are expected to come from the same module. For example, if your expression is <code class="literal">foo+bar</code>
        but the <code class="literal">foo</code> and <code class="literal">bar</code> scalars have been recorded by different modules, the result will be empty.</p><p>The iteration can be restricted by binding some part of the module name to variables,
        and use those variables in other patterns. The <code class="literal">${x=&lt;pattern&gt;}</code> syntax in a module
        name pattern binds the part of the module name matched to <span class="emphasis"><em>pattern</em></span> to a variable named <code class="literal">x</code>.
        These variables can be referred as <code class="literal">${x}</code> in other patterns. The <code class="literal">${...}</code> syntax also allows
        you to embed expressions (e.g. <code class="literal">${x+1}</code>) into the pattern.</p><p>To make use of vectors and histograms in the computation, you can use the <code class="literal">count()</code>,
        <code class="literal">mean()</code>, <code class="literal">min()</code>, <code class="literal">max()</code>, <code class="literal">stddev()</code> and <code class="literal">variance()</code> functions to access their properties
        (e.g. <code class="literal">count(**.mac.pkDrop)</code> or <code class="literal">max('end-to-end delay')</code>).</p><p>The following functions can be applied to scalars or to an expression that yields a scalar value:
        <code class="literal">count()</code>, <code class="literal">mean()</code>, <code class="literal">min()</code>, <code class="literal">max()</code>, <code class="literal">stddev()</code>, <code class="literal">variance()</code>.
        These aggregate functions produce one value for a group of scalars instead of one for each scalar.
        By default, each scalar belongs to the same group, but it is possible to group them by module name (see Grouping).
        Aggregate functions cannot cross simulation run boundaries, e.g they cannot be used to compute average over
        all replications of the same configuration; use the <span class="emphasis"><em>Average replications</em></span> checkbox for that.</p><p><b>Grouping. </b>
        Scalars can be grouped by module or value before the value computation, and you can enter a grouping
        expression here. Grouping is the most useful when you want to use aggregate functions 
        (<code class="literal">count()</code>, <code class="literal">mean()</code>, etc.) in the value expression.</p><p>The grouping expression is evaluated for each statistic in the input dataset, and the resulting value
        denotes the statistic's group. For example, if the expression produces 0 for some statistics
        and 1 for others, there will be two groups. Aggregate functions (<code class="literal">count()</code>, <code class="literal">mean()</code>, etc.)
        are performed on each group independently.</p><p>In the grouping expression, you can refer to the name, module and values of the statistic
        (<code class="literal">module</code>, <code class="literal">name</code> and <code class="literal">value</code>; the latter is only meaningful on scalars, and produces <span class="emphasis"><em>NaN</em></span>
        for histograms and vectors), and to attributes of the simulation run (<code class="literal">run</code>, <code class="literal">configname</code>,
        <code class="literal">runnumber</code>, <code class="literal">experiment</code>, <code class="literal">measurement</code>, <code class="literal">replication</code>, iteration variables of the ini file, etc.)
        However, note that run attributes are not as useful as they would appear, because grouping
        only takes place within simulation runs, you cannot join data from several simulation runs
        into one group this way.</p><p>Often you want derive the group identifier from some part of the module name.
        A useful tool for that is the pattern matching operator (<code class="literal">=~</code>) combined with conditionals (<code class="literal">? :</code>).
        The expression <code class="literal">&lt;str&gt; =~ &lt;pat&gt;</code> matches the string <code class="literal">str</code> with the pattern <code class="literal">pat</code>.
        If there is no match, the value of the expression is <code class="literal">false</code>, otherwise the input string <code class="literal">str</code>
        (which counts as true). The useful bit is that you can bind parts of the matching string to variables
        with the <code class="literal">${x=&lt;pattern&gt;}</code> syntax in the pattern (see above), and you can use those variables
        later in the grouping expression, and also in the <span class="emphasis"><em>Value</em></span>, <span class="emphasis"><em>Name</em></span> and <span class="emphasis"><em>Module</em></span> fields.</p><p><b>Name. </b>
        This is the name for the generated scalars. You can enter a literal string here.
        You can also use dollar variables bound in the <span class="emphasis"><em>Value</em></span> and <span class="emphasis"><em>Grouping</em></span> fields (e.g. <code class="literal">${x}</code>),
        and their expressions (e.g. <code class="literal">${x+y+1}</code>).</p><p><b>Module. </b>
        This is the place where you can enter the module name for the newly computed scalars.
        If the value expression contains unqualified scalars (those without module name patterns)
        that are not subject to aggregate functions, and you agree to place
        the new scalars into the same modules as theirs, then this field can be left empty.
        Otherwise, enter the module name. You can use dollar variables bound in the <span class="emphasis"><em>Value</em></span> and
        <span class="emphasis"><em>Grouping</em></span> fields (e.g. <code class="literal">${x}</code>), and their expressions (e.g. <code class="literal">${x+y+1}</code>).
        Note that the module name does not need to be an existing module name; you can "make up"
        new modules by entering arbitrary names here.</p><p><b>Average replications checkbox. </b>
        Check to compute only the avarage value across repetitions.</p><p>The computation is performed in each run independently by default. If some run is a replication of the same
        measurement with different seeds, you may want to average the results. If the <span class="emphasis"><em>Average replications</em></span> checkbox is
        selected, then only one scalar is added to the dataset for each measurement.</p><p>A new run generated for the scalar which represents the set of replications which it is computed from.
        The attributes of this run are those that have the same value in all replications.</p><p><b>Other checkboxes. </b>
        In addition to mean, you can also add other statistical properties of the computed scalar to the dataset
        by selecting the corresponding checkboxes in the dialog. The names of these new scalars
        will be formed by adding the <code class="literal">:stddev</code>, <code class="literal">:confint</code>, <code class="literal">:min</code>, or <code class="literal">:max</code> suffix
        to the base name of the scalar.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>A more formal description of the <span class="emphasis"><em>Compute Scalars</em></span> feature's operation, together with the
        list of available functions and other details, can be found in the
        Appendix (see <a class="xref" href="apa.html" title="Appendix A. Specification of the 'Compute Scalars' operation">Appendix A, <i>Specification of the 'Compute Scalars' operation</i></a>).</div><p><b>Examples. </b>
        Let us illustrate the usage of the computations with some examples.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Assume that you have several source modules in the network that generate CBR traffic,
          parameterized with packet length (in bytes) and send interval (seconds). Both parameters
          are saved as scalars by each module (<code class="literal">pkLen</code>, <code class="literal">sendInterval</code>), but you want to use the bit rate
          for further computations or charts. Adding a <span class="emphasis"><em>Compute Scalar</em></span> node with the following content
          will create an additional <code class="literal">bitrate</code> scalar for each source module:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">pkLen*8/sendInterval</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">bitrate</code></p></li></ul></div></li><li class="listitem"><p>Assume that several sink modules record <code class="literal">rcvdByteCount</code> scalars, and the simulation
          duration is saved globally as the <code class="literal">duration</code> scalar of the toplevel module. We are interested
          in the throughput at each sink module. In the value expression we can refer to the <code class="literal">duration</code> scalar
          by its qualified name, i.e. prefix it with the full name of its module. <code class="literal">rcvdByteCount</code> can be
          left unqualified, and then the <span class="emphasis"><em>Module</em></span> field doesn't need to be filled out because it will
          be inferred from the <code class="literal">rcvdByteCount</code> statistic.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">8*rcvdByteCount / Network.duration</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">throughput</code></p></li></ul></div></li><li class="listitem"><p>If you are interested in the total number of bytes received in the network,
          you can use the <code class="literal">sum()</code> function. In this example we store the result as a new scalar
          of the toplevel module, <code class="literal">Network</code>.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">sum(rcvdByteCount)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">totalRcvdBytes</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Network</code></p></li></ul></div></li><li class="listitem"><p>If several modules record scalars named <code class="literal">rcvdByteCount</code> but you are only
          interested in the ones recorded from network hosts, you can qualify the scalar name with
          a pattern:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">sum(**.host*.**.rcvdByteCount)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">totalHostRcvdBytes</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Network</code></p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>An alternative solution would be to restrict the input of the Compute Scalars node
          by adding a Select child under it.</div></li><li class="listitem"><p>If several modules record vectors named <code class="literal">end-to-end delay</code> and you are
          interested in the average of the peak end-to-end delays experienced by each module,
          you can use the <code class="literal">max()</code> function on the vectors to get the peak, then <code class="literal">mean()</code>
          to obtain their averages. Note that the vector name needs to be quoted with apostrophes
          because it contains spaces.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">mean(max('end-to-end delay'))</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">avgPeakDelay</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Network</code></p></li></ul></div></li><li class="listitem"><p>Let's assume there are 3 clients (<code class="literal">cli0, cli1, cli2</code>) and 3 servers (<code class="literal">srv0, srv1, srv2</code>)
          in the network, and each client sends datagrams to the corresponding server. The packet loss
          per client-server pair can be computed from the number of sent and received packets.
          We use the <code class="literal">i</code> variable to match the corresponding clients and servers.
          (Without the <code class="literal">i</code> variable, i.e. by writing just <code class="literal">Net.cli*.pkSent - Net.srv*.pkRcvd</code>,
          the result would be Cartesian product.)</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">Net.cli${i={0..2}}.pkSent - Net.srv${i}.pkRcvd</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">pkLoss</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Net.srv${i}</code></p></li></ul></div></li><li class="listitem"><p>A similar example is when you want to compute the total number of transport
          packets (the sum of the TCP and UDP packet counts) for each host. Since the input scalars
          are recorded by different modules, we need the <code class="literal">host</code> variable to match TCP and UDP modules
          under the same host.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">${host=**}.udp.pkCount + ${host}.tcp.pkCount</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">transportPkCount</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">${host}</code></p></li></ul></div></li><li class="listitem"><p>This example is a slight modification of the previous example. Assume that the TCP
          module writes an output vector (named <code class="literal">pkSent</code>) containing the length of each packet sent,
          and the UDP module writes a histogram of the sent packet lengths. As in the previous example,
          we want to compute the number of sent packets for each host; we use <code class="literal">count()</code> to
          extract the number of values from histograms and output vectors.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">count(${host=**}.udp.pkSent) + count(${host}.tcp.pkSent)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">pkCount</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">${host}</code></p></li></ul></div></li><li class="listitem"><p>Now we are computing the average number of data packets sent by the hosts. We will use
          the <code class="literal">mean()</code> function in the <span class="emphasis"><em>Value</em></span> expression: <code class="literal">mean(${host=**}.udp.pkCount + ${host}.tcp.pkCount)</code>.
          The <code class="literal">mean</code> function computes one value from a set of values. Because this value can not be associated
          with one host, the <code class="literal">host</code> variable will be undefined outside the <code class="literal">mean()</code> function call. Therefore
          you can not enter <code class="literal">${host}</code> into the <span class="emphasis"><em>Module</em></span>, but an appropriate module name should be choosen.
          Important: the <code class="literal">mean()</code> function cannot be used to compute the average of values that come from different
          runs, as the <span class="emphasis"><em>Value</em></span> expression is always evaluated with input statistics that come from the
          same run; you have to use the <span class="emphasis"><em>Average replications</em></span>  checkbox for that instead.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">mean(${host=**}.udp.pkCount + ${host}.tcp.pkCount))</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">avgPkCount</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Network</code></p></li></ul></div></li><li class="listitem"><p>Again, we are interested in the average number of sent packets, but we want
          to compute the average for each subnet. In SQL you would use the GROUP BY clause to generate that report,
          here you can use the <span class="emphasis"><em>Grouping</em></span> expression. Let us assume that the subnets are at the second level
          of the module hierarhcy, so they can be identified by the second component of the full names of modules.
          Giving <code class="literal">(module =~ *.${subnet=*}.**) ? subnet : "n/a"</code> as the <span class="emphasis"><em>Grouping</em></span> expression, the group identifier
          will be the subnet of the modules (and <code class="literal">n/a</code> for the network). Now the same <span class="emphasis"><em>Value</em></span> expression as
          in the previous example computes the average for each subnet. The <code class="literal">group</code> variable now contains the
          name of the subnet, so you can use the <code class="literal">${group}</code> expression as the <span class="emphasis"><em>Module</em></span>.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">mean(${host=**}.udp.pkCount + ${host}.tcp.pkCount))</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Grouping</strong></span>: <code class="literal">(module =~ *.${subnet=*}.**) ? subnet : "n/a"</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">avgPkCount</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">${group}</code></p></li></ul></div></li><li class="listitem"><p>It is also possible to group the scalars by their values.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">count(responseTime)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Grouping</strong></span>: <code class="literal">value &gt; 1.0 ? "Large" : "Normal"</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">num${group}ResponseTimes</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="emphasis"><em>or:</em></span> <code class="literal">${"num" ++ group ++ "ResponseTimes"}</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Network</code></p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>Note the use of <code class="literal">++</code> for string concatenation in the name expression. The normal <code class="literal">+</code> operator
          does numeric addition, and it would attempt to convert both operands to a numbers beforehand.</div></li><li class="listitem"><p>Assume that you run the simulation with the same parameter settings, but different seeds,
          i.e. you have runs that are replications of the same measurement. Then computations are repeated for each
          run, therefore they produce values for each replications. If you are not interested in the individual
          results in the replications, you can generate only their average by turning on the <span class="emphasis"><em>Average replications</em></span>
          checkbox. The average will be saved with the name entered into the <span class="emphasis"><em>Name</em></span> field. The minimum/maximum
          value, the standard deviation of the distribution, and the confidence interval of the mean can also
          be generated. Their name will contain a <code class="literal">:min</code>, <code class="literal">:max</code>, <code class="literal">:stddev</code>, <code class="literal">:confint</code> suffix.</p></li><li class="listitem"><p>To add a constant value as a scalar, enter the value into <span class="emphasis"><em>Value</em></span> field,
          its name into the <span class="emphasis"><em>Name</em></span>, and the module name into the <span class="emphasis"><em>Module</em></span> field. Note that you can
          use any name for the target module, not just names of existing modules. As a result of the computation,
          one scalar will be added in every run that is present in the input dataset.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">299792458</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">speedOfLight</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Network.channelControl</code></p></li></ul></div></li><li class="listitem"><p>If you want to add the constant for each module in your dataset, then enter <code class="literal">module</code> into
          the <span class="emphasis"><em>Grouping</em></span> field, and <code class="literal">${group}</code> into the <span class="emphasis"><em>Module</em></span> field. In this case
          the statistics of the input dataset are grouped not only by their run, but by their module name too.
          The expression entered into the <span class="emphasis"><em>Grouping</em></span> field is a predefined variable, that refers
          to the module name of the statistic which the group identifier is generated for. We refer to the
          value of the group identifier (i.e. the module name) in the <span class="emphasis"><em>Module</em></span> field.
          </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">3.1415927</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Grouping</strong></span>: <code class="literal">module</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">pi</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">${group}</code></p></li></ul></div></li><li class="listitem"><p>Sometimes multiple steps are needed to compute what you need. Assume you have
          a network where various modules record ping round-trip delays (RTT), and you want to count the modules
          with large RTT values (where the average RTT is more than twice the global average in the network).
          The following examples achieves that. Step 1 and 2 could be merged, but we left them separate 
          for better readability.</p><p>Step 1:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">mean('rtt:vector')</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">average</code></p></li></ul></div><p>Step 2:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">average / mean(**.average)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">relativeAverage</code></p></li></ul></div><p>Step 3:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">count(relativeAverage)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Grouping</strong></span>: <code class="literal">value &gt; 2.0  ? "Above" : "Normal"</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">num${group}</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Net</code></p></li></ul></div></li><li class="listitem"><p>In this example, we have 100 routers (<code class="literal">Net.rte[0]..Net.rte[99] </code>) that
          all record the number of dropped packets (<code class="literal">drops</code> scalar), and we want to know how many routers
          dropped 0..99 packets, 100..199 packets, 200..299 packets, and so on. For this we group the scalars
          by their values, and count the scalars in each group.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">count(drops)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Grouping</strong></span>: <code class="literal">floor(value / 100)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">values in the ${group}00- group</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Net</code></p></li></ul></div></li><li class="listitem"><p>Assume we have the same 100 routers with drop count scalars as in the previous example.
          We want to group the routers in batches of 10 by index, and compute the average drop count in each batch.</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">mean(drops)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Grouping</strong></span>: <code class="literal">(module=~ *.rte[${index=*}]) ? floor(index/10) : "n/a"</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">avgDropsInGroup${group}</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Net</code></p></li></ul></div></li><li class="listitem"><p>This is a variation of the previous example: if the batches are not of equal size, we can 
          use the <code class="literal">locate(x,a1,a2,a3,...an)</code> function to group them. <code class="literal">locate()</code> returns the index of the first element
          of <span class="emphasis"><em>a1..an</em></span> that is less or equal than <span class="emphasis"><em>x</em></span> (or 0 if <span class="emphasis"><em>x &lt; a1</em></span>). </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Value</strong></span>: <code class="literal">mean(drops)</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Grouping</strong></span>:</p></li><li class="listitem" style="list-style-type: none"><p>  <code class="literal">(module=~ *.rte[${index=*}]) ? locate(index,5,15,35,85) : "n/a"</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Name</strong></span>: <code class="literal">avgDropsInGroup${group}</code></p></li><li class="listitem" style="list-style-type: none"><p><span class="bold"><strong>Module</strong></span>: <code class="literal">Net</code></p></li></ul></div></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5151"></a>Export</h4></div></div></div><p> You can export the content of the dataset into text files. Three formats are supported: comma
          separated values (CSV), Octave text files and Matlab script. Right-click on the processing node or
          chart, and select the format from the <span class="emphasis"><em>Export to File</em></span> submenu. The file will contain the data of
          the chart, or the dataset after the selected processing is applied. Enter the name of the file and
          press <span class="emphasis"><em>Finish</em></span>.</p><p>
          Vectors are always written as two columns into the CSV files, but the shape of the scalars table
          can be changed by selecting the grouping attributes in the dialog. For example, assume we have two scalars
          (named s1 and s2) written by two modules (m1 and m2) in two runs (r1 and r2), resulting in a total of 8
          scalar values. If none of the checkboxes is selected in the <span class="emphasis"><em>Scalars grouped by</em></span> group, then the
          data is written as:
          </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col width="48pt"><col width="48pt"><col width="48pt"><col width="48pt"><col width="48pt"><col width="48pt"><col width="48pt"><col width="48pt"></colgroup><thead><tr><th>r1 m1 s1</th><th>r1 m1 s2</th><th>r1 m2 s1</th><th>r1 m2 s2</th><th>r2 m1 s1</th><th>r2 m1 s2</th><th>r2 m2 s1</th><th>r2 m2 s2</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr></tbody></table></div><p>
          Grouping the scalars by module name and scalar name would have the following result:
          </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col width="48pt"><col width="48pt"><col width="48pt"><col width="48pt"></colgroup><thead><tr><th>Module</th><th>Name</th><th>r1</th><th>r2</th></tr></thead><tbody><tr><td>m1</td><td>s1</td><td>1</td><td>5</td></tr><tr><td>m1</td><td>s2</td><td>2</td><td>6</td></tr><tr><td>m2</td><td>s1</td><td>3</td><td>7</td></tr><tr><td>m2</td><td>s2</td><td>4</td><td>8</td></tr></tbody></table></div><p>
        </p><p>The settings specific to the file format are:</p><p><b>CSV. </b> You can select the separator, line ends and quoting character. The default setting
            corresponds to RFC4180. The precision of the numeric values can also be set. The CSV file contains
            an optional header followed by the vector's data or groups of scalars. If multiple vectors are
            exported, each vector is written into a separate file.</p><p><b>Octave. </b>
            The data is exported as an Octave text file. This format can be loaded into the
            <a class="ulink" href="http:://www.r-project.org" target="_top">R</a>
            statistical data analysis tool, as well. The tables are saved as structures containing an array for
            each column.
          </p><p><b>Matlab. </b> The data is exported as a Matlab script file. It can be loaded into Matlab/Octave with the
            source() function.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5232"></a>Chart sheets</h4></div></div></div><p> Sometimes, it is useful to display several charts on one page. When you create a chart, it is
          automatically added to a default chart sheet. Chart sheets and the their charts are displayed on the
          lower pane of the <span class="emphasis"><em>Datasets</em></span> page. To create a new chart sheet, use the <span class="emphasis"><em>Chart Sheet</em></span> button on the
          palette. You can add charts to it either by using the opening dialog or by dragging charts. To move
          charts between chart sheets, use drag and drop or Cut/Paste. You can display the charts by
          double-clicking on the chart sheet node.</p><div class="figure"><a name="pictures/ANF-ChartSheetPage.png"></a><p class="title"><b>Figure 10.6. Chart Sheet page with three charts</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-ChartSheetPage.png" align="middle" alt="Chart Sheet page with three charts"></div></div></div></div><br class="figure-break"></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="charts"></a>Charts</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5247"></a>Overview</h4></div></div></div><p>
          You typically want to display the recorded data in charts. In OMNeT&#8288;+&#8288;+
          4.x, you can open charts for scalar, vector or histogram data with one click. Charts can be saved
          into the analysis file, too. The Analysis Editor supports bar charts, line charts, histogram charts
          and scatter charts. Charts are interactive; users can zoom, scroll, and access tooltips that give
          information about the data items.
        </p><p> Charts can be customized. Some of the customizable options include titles, fonts, legends, grid
          lines, colors, line styles, and symbols.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5251"></a>Creating charts</h4></div></div></div><p> To create a chart, use the palette on the <span class="emphasis"><em>Dataset</em></span> page. Drag the chart button and drop it to
          the dataset at the position you want it to appear. If you press the chart button then it opens a
          dialog where you can edit the properties of the new chart. In this case the new chart will be added
          at the end of the selected dataset or after the selected dataset item.</p><p>
          Temporary charts can be created on the <span class="emphasis"><em>Browse Data</em></span> page for quick view. Select the scalars, vectors
          or histograms and choose <span class="emphasis"><em>Plot</em></span> from the context menu. If you want to save such a temporary chart
          in the analysis, then choose <span class="emphasis"><em>Convert to dataset...</em></span> from the context menu of the chart or
          <span class="guibutton"><img src="icons/template.gif"></span>
          from the toolbar.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5261"></a>Editing charts</h4></div></div></div><p> You can open a dialog for editing charts from the context menu. The dialog is divided into
          several pages. The pages can be opened directly from the context menu. When you select a line and
          choose <span class="emphasis"><em>Lines...</em></span> from the menu, you can edit the properties of the selected line.</p><p>
          You can also use the <span class="emphasis"><em>Properties View</em></span> to edit the chart. It is recommended that users display the
          properties grouped according to their category (<span class="guibutton"><img src="icons/Eclipse_ShowCategories.png"></span>
          on the toolbar of the <span class="emphasis"><em>Properties View</em></span>).
        </p><div class="table"><a name="idm5270"></a><p class="title"><b>Table 10.2. Common chart properties</b></p><div class="table-contents"><table class="table" summary="Common chart properties" border="1"><colgroup><col class="name"><col class="description"></colgroup><tbody><tr><td colspan="2" align="left">Main</td></tr><tr><td>antialias</td><td>Enables antialising.</td></tr><tr><td>caching</td><td>Enables caching. Caching makes scrolling faster, but sometimes the plot might not be correct.</td></tr><tr><td>background color</td><td>Background color of the chart.</td></tr><tr><td colspan="2" align="left">Titles</td></tr><tr><td>graph title</td><td>Main title of the chart.</td></tr><tr><td>graph title font</td><td>Font used to draw the title.</td></tr><tr><td>x axis title</td><td>Title of the horizontal axis.</td></tr><tr><td>y axis title</td><td>Title of the vertical axis.</td></tr><tr><td>axis title font</td><td>Font used to draw the axes titles.</td></tr><tr><td>labels font</td><td>Font used to draw the tick labels.</td></tr><tr><td>x labels rotated by</td><td>Rotates the tick labels of the horizontal axis by the given angle (in degrees).</td></tr><tr><td colspan="2" align="left">Axes</td></tr><tr><td>y axis min</td><td>Crops the input below this y value.</td></tr><tr><td>y axis max</td><td>Crops the input above this y value.</td></tr><tr><td>y axis logarithmic</td><td>Applies a logarithmic transformation to the y values.</td></tr><tr><td>grid</td><td>Add grid lines to the plot.</td></tr><tr><td colspan="2" align="left">Legend</td></tr><tr><td>display</td><td>Displays the legend.</td></tr><tr><td>border</td><td>Add border around the legend.</td></tr><tr><td>font</td><td>Font used to draw the legend items.</td></tr><tr><td>position</td><td>Position of the legend.</td></tr><tr><td>anchor point</td><td>Anchor point of the legend.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5342"></a>Zooming and panning</h4></div></div></div><p>
          Charts have two mouse modes. In Pan mode, you can scroll with the mouse wheel and drag the chart. In
          Zoom mode, the user can zoom in on the chart by left-clicking and zoom out by doing a
          <span class="keycap"><strong>Shift</strong></span>+<span class="mousebutton">left</span>
          click, or using the mouse wheel. Dragging selects a rectangular area for zooming. The toolbar icons
          <span class="guibutton"><img src="icons/hand.gif"></span>
          and
          <span class="guibutton"><img src="icons/zoom.png"></span>
          switch between Pan and Zoom modes. You can also find toolbar buttons to zoom in
          <span class="guibutton"><img src="icons/zoomplus.png"></span>
          , zoom out (<span class="guibutton"><img src="icons/zoomminus.png"></span>) and zoom to fit (<span class="guibutton"><img src="icons/zoomtofit.png"></span>). Zooming and moving actions are remembered in the navigation history.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5358"></a>Tooltip</h4></div></div></div><p>
          When the user hovers the mouse over a data point, the appearing tooltip shows line labels and the values
          of the points close to the cursor. The names of all lines can be displayed by hovering over the
          <span class="guibutton"><img src="icons/legend.gif"></span>
          button at the top right corner of the chart.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5363"></a>Copy to clipboard</h4></div></div></div><p> You can copy the chart to the clipboard by selecting <span class="emphasis"><em>Copy to Clipboard</em></span> from the context
          menu. The chart is copied as a bitmap image and is the same size as the chart on the screen.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5367"></a>Bar charts</h4></div></div></div><p> Bar charts display scalars as groups of vertical bars. The bars can be positioned within a
          group next to, above or in front of each other. The baseline of the bars can be changed. Optionally,
          a logarithmic transformation can be applied to the values.</p><div class="figure"><a name="pictures/ANF-ScalarChart.png"></a><p class="title"><b>Figure 10.7. Bar chart</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-ScalarChart.png" align="middle" alt="Bar chart"></div></div></div></div><br class="figure-break"><p> The scalar chart's content can be specified on the <span class="emphasis"><em>Content</em></span> tab of their <span class="emphasis"><em>Properties</em></span>
          dialog. Attributes in the "Groups" list box determine the groups so that within a group each
          attribute has the same value. Attributes in the "Bars" list box determine the bars; the bar height
          is the average of scalars that have the same values as the "Bar" attributes. You can classify the
          attributes by dragging them from the upper list boxes to the lower list boxes. You will normally
          want to group the scalars by modules and label the bars with the scalar name. This is the default
          setting, if you leave each attribute in the upper list box.</p><div class="figure"><a name="pictures/ANF-ScalarChartEditDialog.png"></a><p class="title"><b>Figure 10.8. Dialog page for bar chart content</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-ScalarChartEditDialog.png" align="middle" alt="Dialog page for bar chart content"></div></div></div></div><br class="figure-break"><p> In addition to the common chart properties, the properties of bar charts include:</p><div class="table"><a name="idm5390"></a><p class="title"><b>Table 10.3. Bar chart properties</b></p><div class="table-contents"><table class="table" summary="Bar chart properties" border="1"><colgroup><col class="name"><col class="description"></colgroup><tbody><tr><td colspan="2" align="left">Titles</td></tr><tr><td>wrap labels</td><td>If true labels are wrapped, otherwise aligned vertically.</td></tr><tr><td colspan="2" align="left">Plot</td></tr><tr><td>bar baseline</td><td>Baseline of the bars.</td></tr><tr><td>bar placement</td><td>Arrangement of the bars within a group.</td></tr><tr><td colspan="2" align="left">Bars</td></tr><tr><td>color</td><td>Color of the bar. Color name or #RRGGBB. Press Ctrl+Space for a list of color names.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5415"></a>Line charts</h4></div></div></div><p> Line charts can be used to display output vectors. Each vector in the dataset gives a line on
          the chart. You can specify the symbols drawn at the data points (cross, diamond, dot, plus, square
          triangle or none), how the points are connected (linear, step-wise, pins or none) and the color of
          the lines. Individual lines can be hidden.</p><div class="figure"><a name="pictures/ANF-VectorChart.png"></a><p class="title"><b>Figure 10.9. Line chart</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-VectorChart.png" align="middle" alt="Line chart"></div></div></div></div><br class="figure-break"><p>
          Line names identify lines on the legend, property sheets and edit dialogs. They are formed
          automatically from attributes of the vector (like file, run, module, vector name, etc.). If you want
          to name the lines yourself, you can enter a name pattern in the <span class="emphasis"><em>Line names</em></span> field of the
          <span class="emphasis"><em>Properties</em></span> dialog (<span class="emphasis"><em>Main</em></span> tab). You can use "{file}", "{run}", "{module}", or "{name}" to refer
          to an attribute value. Press
          <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Space</strong></span>
          for the complete list.
        </p><p> Processing operations can be applied to the dataset of the chart by selecting <span class="emphasis"><em>Apply</em></span> or
          <span class="emphasis"><em>Compute</em></span> from the context menu. If you want to remove an existing operation, you can do it from
          the context menu, too.</p><p> Line charts are synchronized with <span class="emphasis"><em>Output Vector</em></span> and <span class="emphasis"><em>Dataset</em></span> views. Select a data point
          and you will see that the data point and the vector are selected in the Output Vector and <span class="emphasis"><em>Dataset View,</em></span> as well.
        </p><div class="table"><a name="idm5440"></a><p class="title"><b>Table 10.4. Line chart properties</b></p><div class="table-contents"><table class="table" summary="Line chart properties" border="1"><colgroup><col class="name"><col class="description"></colgroup><tbody><tr><td colspan="2" align="left">Axes</td></tr><tr><td>x axis min</td><td>Crops the input below this x value.</td></tr><tr><td>x axis max</td><td>Crops the input above this x value.</td></tr><tr><td colspan="2" align="left">Lines</td></tr><tr><td>display name</td><td>Display name of the line.</td></tr><tr><td>display line</td><td>Displays the line.</td></tr><tr><td>symbol type</td><td>The symbol drawn at the data points.</td></tr><tr><td>symbol size</td><td>The size of the symbol drawn at the data points.</td></tr><tr><td>line type</td><td>Line drawing method. One of Linear, Pins, Dots, Points, Sample-Hold or Backward Sample-Hold.</td></tr><tr><td>line color</td><td>Color of the line. Color name or #RRGGBB. Press Ctrl+Space for a list of color names.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5475"></a>Histogram charts</h4></div></div></div><p>
          Histogram charts can display data of histograms. They support three view modes:
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Count</span></dt><dd><p>The chart shows the recorded counts of data points in each cell.</p></dd><dt><span class="term">Probability density</span></dt><dd><p> The chart shows the probability density function computed from the histogram data.
                </p></dd><dt><span class="term">Cumulative density</span></dt><dd><p> The chart shows the cumulative density function computed from the histogram data.
                </p></dd></dl></div><p>
        </p><div class="figure"><a name="pictures/ANF-HistogramChart.png"></a><p class="title"><b>Figure 10.10. Histogram chart</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-HistogramChart.png" align="middle" alt="Histogram chart"></div></div></div></div><br class="figure-break"><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p> When drawing several histograms on one chart, set the "Bar type" property to Outline. This
            way the histograms will not cover each other.</p></div><div class="table"><a name="idm5501"></a><p class="title"><b>Table 10.5. Histogram chart properties</b></p><div class="table-contents"><table class="table" summary="Histogram chart properties" border="1"><colgroup><col class="name"><col class="description"></colgroup><tbody><tr><td colspan="2" align="left">Plot</td></tr><tr><td>bar type</td><td>Histogram drawing method.</td></tr><tr><td>bar baseline</td><td>Baseline of the bars.</td></tr><tr><td>histogram data type</td><td>Histogram data. Counts, probability density and cumulative density can be displayed.</td></tr><tr><td>show overflow cell</td><td>Show over/underflow cells.</td></tr><tr><td colspan="2" align="left">Histograms</td></tr><tr><td>hist color</td><td>Color of the bar. Color name or #RRGGBB. Press Ctrl+Space for a list of color names.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm5527"></a>Scatter charts</h4></div></div></div><p> Scatter charts can be created from both scalar and vector data. You have to select one
          statistic for the x coordinates; other data items give the y coordinates. How the x and y values are
          paired differs for scalars and vectors.</p><p><b>Scalars. </b> For each value of the x scalar, the y values are selected from scalars in the same run.
          </p><p><b>Vectors. </b> For each value of the x vector, the y values are selected from the same run and with the same
            simulation time.</p><div class="figure"><a name="pictures/ANF-ScatterChart.png"></a><p class="title"><b>Figure 10.11. A scatter chart</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-ScatterChart.png" align="middle" alt="A scatter chart"></div></div></div></div><br class="figure-break"><p> By default, each data point that comes from the same y scalar belongs to the same line. This is
          not always what you want because these values may have been generated in runs having different
          parameter settings; therefore, they are not homogenous. You can specify scalars to determine the "iso" lines of
          the scatter chart. Only those points that have the same values of these "iso" attributes are connected
          by lines.</p><div class="figure"><a name="pictures/ANF-ScatterOptions.png"></a><p class="title"><b>Figure 10.12. A scatter chart</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject" align="center"><img src="pictures/ANF-ScatterOptions.png" align="middle" alt="A scatter chart"></div></div></div></div><br class="figure-break"><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p> If you want to use a module parameter as an iso attribute, you can record it as a scalar by
            setting "&lt;module&gt;.&lt;parameter_name&gt;.param-record-as-scalar=true"
            in the INI file.
          </p></div><div class="table"><a name="idm5555"></a><p class="title"><b>Table 10.6. Scatter chart properties</b></p><div class="table-contents"><table class="table" summary="Scatter chart properties" border="1"><colgroup><col class="name"><col class="description"></colgroup><tbody><tr><td colspan="2" align="left">Axes</td></tr><tr><td>x axis min</td><td>Crops the input below this x value.</td></tr><tr><td>x axis max</td><td>Crops the input above this x value.</td></tr><tr><td colspan="2" align="left">Lines</td></tr><tr><td>display name</td><td>Display name of the line.</td></tr><tr><td>display line</td><td>Displays the line.</td></tr><tr><td>symbol type</td><td>The symbol drawn at the data points.</td></tr><tr><td>symbol size</td><td>The size of the symbol drawn at the data points.</td></tr><tr><td>line type</td><td>Line drawing method. One of Linear, Pins, Dots, Points, Sample-Hold or Backward Sample-Hold.</td></tr><tr><td>line color</td><td>Color of the line. Color name or #RRGGBB. Press Ctrl+Space for a list of color names.</td></tr></tbody></table></div></div><br class="table-break"></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch10s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch10.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch10s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Creating Analysis Files </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Associated Views</td></tr></table></div></body></html>
