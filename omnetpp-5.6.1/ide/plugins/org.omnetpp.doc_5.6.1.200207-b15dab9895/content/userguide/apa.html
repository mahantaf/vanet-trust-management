<html><head><link rel="STYLESHEET" href="../book.css"  type="text/css"/><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Appendix A. Specification of the 'Compute Scalars' operation</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="OMNeT&#8288;+&#8288;+ User Guide"><link rel="up" href="index.html" title="OMNeT&#8288;+&#8288;+ User Guide"><link rel="prev" href="ch12s03.html" title="Project-Specific Extensions"><link rel="next" href="apas02.html" title="Computing Scalars"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Appendix A. Specification of the 'Compute Scalars' operation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch12s03.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="apas02.html">Next</a></td></tr></table><hr></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="computed-scalar-spec"></a>Appendix A. Specification of the 'Compute Scalars' operation</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="apa.html#idm5764">Expressions</a></span></dt><dt><span class="sect1"><a href="apas02.html">Computing Scalars</a></span></dt></dl></div><p>This appendix describes the <span class="emphasis"><em>Compute Scalars</em></span> operation in details.
  Some fields of the operation can contain expressions, so we first describe the expressions.
  The <span class="emphasis"><em>Compute Scalars</em></span> operation is described in the following section.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm5764"></a>Expressions</h2></div></div></div><p> An expression is composed of constants, scalar values, vector or histogram fields,
    variables, operators, and functions.
    </p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm5767"></a>Constants</h3></div></div></div><p>Numeric contants are accepted in the standard format.</p><p>Examples: <code class="literal">-1</code>, <code class="literal">3.14159</code>, <code class="literal">4.2e1</code></p><p>String constants must be enclosed with double quotes. Double quotes within the string must be preceded by a
    backslash character.</p><p>Examples: <code class="literal">"xyz"</code>, <code class="literal">"This string contains a \" character"</code></p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm5778"></a>Scalars</h3></div></div></div><p>The values of scalars in the input dataset can be accessed in two ways:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Simple names. </b>Using the name of a scalar in the expression refers to all scalar with that name.
    If the name of the scalar contains non-alphanumeric characters, it must be enclosed with
    apostrophies.</p></li><li class="listitem"><p><b>Qualified names. </b>Qualified names are in the form <code class="literal">&lt;module&gt;.&lt;scalar&gt;</code>. Here <code class="literal">&lt;module&gt;</code>
    is a pattern (see ...) that matched to the full name of the module of the scalar; <code class="literal">&lt;scalar&gt;</code>
    is the name of the scalar (quoted if needed). As a special case, <code class="literal">&lt;module&gt;</code> can
    also be the full name of the module.</p></li></ul></div><p>Note that the scalar references may produce multiple values. Consequently the expression
    that contains them may also produce multiple values by iterating on the values of the scalars.
    The iteration is defined differently for the two types of scalars references:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Scalars referenced by their simple names are restricted to come from the same module.
    For example, if we have four scalars recorded by two modules, <code class="literal">m1.a</code>, <code class="literal">m1.b</code>, <code class="literal">m2.a</code>, <code class="literal">m2.b</code>,
    then <code class="literal">a+b</code> produces two values: <code class="literal">m1.a+m1.b</code> and <code class="literal">m2.a+m2.b</code>.</p></li><li class="listitem"><p>Scalars referenced by their qualified names are iterated independently on their modules.
    This means that if there are several such pattern in the expression, than the computation is performed
    on their cartesian product. With the input of the previous example, <code class="literal">*.a+*.b</code> produces
    four values: <code class="literal">m1.a+m1.b</code>, <code class="literal">m1.a+m2.b</code>, <code class="literal">m2.a+m1.b</code>, and <code class="literal">m2.a+m2.b</code>.</p><p>
    The iteration can be restricted by binding some part of the module name to variables,
    and use those variables in other patterns. The <code class="literal">${x=&lt;pattern&gt;}</code> syntax in a module name
    pattern binds the part of the module name matched to pattern to a variable named <code class="literal">x</code>.
    These variables can be referred as <code class="literal">${x}</code> in other patterns. The <code class="literal">${...}</code> syntax allows to write
    any expression in the pattern (like <code class="literal">${x+1}</code>).</p></li></ul></div><p>
    </p><p>Examples: <code class="literal">iaTime</code>, <code class="literal">'sentPk:count'</code>, <code class="literal">Aloha.server.duration</code>,
                    <code class="literal">cli${i={0..2}}.pkSent</code>, <code class="literal">**.host[${i+2}].'end-to-end-delay'</code></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Simple scalars references can be viewed as a shortcut for qualified references, where
    the module part is <code class="literal">${m=**}</code> in the first reference, and <code class="literal">${m}</code> in the subsequent references
    (here <code class="literal">m</code> is a fresh variable name). E.g. if <code class="literal">a</code>, and <code class="literal">b</code> are scalars, then <code class="literal">a*b</code> is equivalent
    to <code class="literal">${m=**}.a * ${m}.b</code>.</p></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm5833"></a>Vectors and Histograms</h3></div></div></div><p>To refer to a field of a vector or histogram, use <code class="literal">count(&lt;name&gt;)</code>,
    <code class="literal">mean(&lt;name&gt;)</code>, <code class="literal">min(&lt;name&gt;)</code>, <code class="literal">max(&lt;name&gt;)</code>,
    <code class="literal">stddev(&lt;name&gt;)</code>, and <code class="literal">variance(&lt;name&gt;)</code>.
    Here <code class="literal">&lt;name&gt;</code> is the simple or qualified name of the vector or histogram.</p><p>The same rules apply to qualified names and iterations over modules, as in the
    case of scalars.</p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm5844"></a>Patterns</h3></div></div></div><p>Patterns can be used to specify the module name of an input statistic, or as the right-hand-side
    of the pattern matching operator (<code class="literal">=~</code>). Characters of the patterns are matched literally, except
    the following:</p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Pattern</th><th>Description</th></tr></thead><tbody><tr><td>?</td><td>matches any character</td></tr><tr><td>*</td><td>matches zero or more characters except '.'</td></tr><tr><td>**</td><td>matches zero or more characters (any character)</td></tr><tr><td>{a-z}</td><td>matches a character in range a-z</td></tr><tr><td>{^a-z}</td><td>matches a character not in range a-z</td></tr><tr><td>{32..255}</td><td>any number (i.e. sequence of digits) in range 32..255 (e.g. "99")</td></tr><tr><td>[32..255]</td><td>any number in square brackets in range 32..255 (e.g. "[99]")</td></tr><tr><td>${x=**}</td><td>matches a pattern, and binds the matched substring to x</td></tr><tr><td>${x+1}</td><td>evaluates an expression, and matches the characters of the result</td></tr><tr><td>\</td><td>takes away the special meaning of the subsequent character</td></tr></tbody></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm5887"></a>Variables</h3></div></div></div><p>Variables can be defined by using the <code class="literal">${&lt;var&gt;=...}</code> notation in patterns. The scope of
    the variable is to the right of its definition. There can also be some predefined variables, and
    variables defined in one expression can be accessible in another.</p><p>Predefined variables</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">in <span class="emphasis"><em>Grouping expression</em></span></span></dt><dd><p><code class="literal">module</code>, <code class="literal">name</code>, <code class="literal">run</code>, run attributes of the current statistics,
    <code class="literal">value</code> if the current statistics is a scalar</p></dd><dt><span class="term">in <span class="emphasis"><em>Value expression</em></span></span></dt><dd><p><code class="literal">group</code> is the value of the grouping expression</p></dd><dt><span class="term">in <span class="emphasis"><em>Target module</em></span></span></dt><dd><p><code class="literal">group</code> is the value of the grouping expression</p></dd></dl></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm5914"></a>Operators</h3></div></div></div><p>The following operators are interpreted as usual:</p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col align="center"></colgroup><tbody><tr><td>Arithmetic</td><td align="center"><code class="literal">+ - * / ^ %</code></td></tr><tr><td>Bitwise</td><td align="center"><code class="literal">~ | &amp; # &lt;&lt; &gt;&gt;</code></td></tr><tr><td>Concatenation</td><td align="center"><code class="literal">++</code></td></tr><tr><td>Comparision</td><td align="center"><code class="literal">== != &lt; &gt; &lt;= &gt;=</code></td></tr><tr><td>Boolean</td><td align="center"><code class="literal">! || &amp;&amp;</code></td></tr><tr><td>Conditional</td><td align="center"><code class="literal">?:</code></td></tr><tr><td>Pattern matching</td><td align="center"><code class="literal">=~</code></td></tr></tbody></table></div><p> Arithmetic, bitwise, concatenation, boolean, and comparision operators always evaluate
    their arguments; binary operators evaluate their left arguments first.
    Arithmetic, bitwise, and comparision operators implicitly convert their arguments to numeric values,
    the concatenation operator converts them to strings, the boolean operators converts them to boolean
    values. A runtime error occurs if the conversion fails.
    </p><p>The conditional operator (<code class="literal">cond ? a : b</code>) is special, because it does not evaluate all operands.
    If the condition is true, then the second, otherwise the third operand is evaluated.</p><p>The pattern matching operator <code class="literal">=~</code> expects a string expression as the left, and
    a pattern as the right operand. If the pattern matches with the string, then the result is
    the string, otherwise <code class="literal">false</code>.</p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm5956"></a>Functions</h3></div></div></div><p>The following functions compute an aggregated value from a set of values:</p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">count(&lt;expr&gt;)</code></td><td>count of the values produced by <code class="literal">&lt;expr&gt;</code></td></tr><tr><td><code class="literal">sum(&lt;expr&gt;)</code></td><td>sum of the values produced by <code class="literal">&lt;expr&gt;</code></td></tr><tr><td><code class="literal">min(&lt;expr&gt;)</code></td><td>minimum of the values produced by <code class="literal">&lt;expr&gt;</code></td></tr><tr><td><code class="literal">max(&lt;expr&gt;)</code></td><td>maximum of the values produced by <code class="literal">&lt;expr&gt;</code></td></tr><tr><td><code class="literal">mean(&lt;expr&gt;)</code></td><td>mean of the values produced by <code class="literal">&lt;expr&gt;</code></td></tr><tr><td><code class="literal">stddev(&lt;expr&gt;)</code></td><td>standard deviation of the values produced by <code class="literal">&lt;expr&gt;</code></td></tr><tr><td><code class="literal">variance(&lt;expr&gt;)</code></td><td>variance of the values produced by <code class="literal">&lt;expr&gt;</code></td></tr></tbody></table></div><p>The following functions are not aggregating functions; if their arguments has multiple values,
    then the applying the function also produces multiple values by iterating on them. </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col align="left" class="fun"><col class="desc"></colgroup><thead><tr><th align="left">Function</th><th>Description</th></tr></thead><tbody><tr><td colspan="2" align="left"><span class="emphasis"><em>Math functions</em></span></td></tr><tr><td align="left"><code class="literal">sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(x,y), exp(x), log(x),</code>
                   <code class="literal">log10(x), sqrt(x), cbrt(x), hypot(x,y), sinh(x), cosh(x), tanh(x), </code>
                   <code class="literal">ceil(x), floor(x), round(x), signum(x), min(x,y), max(x,y)</code></td><td>These functions produce the same value as the similarly named methods of
            the <code class="literal">java.lang.Math</code> class in Java.</td></tr><tr><td align="left"><code class="literal">deg(x), rad(x)</code></td><td>Conversion from radians to degrees, and from degrees to radians</td></tr><tr><td align="left"><code class="literal">fabs(x)</code></td><td>Absolute value of <code class="literal">x</code></td></tr><tr><td align="left"><code class="literal">rem(x,y)</code></td><td>IEEE floating point remainder of <code class="literal">x</code> and <code class="literal">y</code></td></tr><tr><td colspan="2" align="left"><span class="emphasis"><em>String functions</em></span></td></tr><tr><td align="left"><code class="literal">length(s)</code></td><td>Returns the length of the string.</td></tr><tr><td align="left"><code class="literal">contains(s, substr)</code></td><td>Returns true if string <code class="literal">s</code> contains <code class="literal">substr</code> as substring.</td></tr><tr><td align="left"><code class="literal">substring(s, pos, len?)</code></td><td>Return the substring of <code class="literal">s</code> starting at the given position, either to the end of the string or maximum <code class="literal">len</code> characters.</td></tr><tr><td align="left"><code class="literal">substringBefore(s, substr)</code></td><td>Returns the substring of <code class="literal">s</code> before the first occurrence of <code class="literal">substr</code>, or the empty string if <code class="literal">s</code> does not contain <code class="literal">substr</code>.</td></tr><tr><td align="left"><code class="literal">substringAfter(s, substr)</code></td><td>Returns the substring of <code class="literal">s</code> after the first occurrence of <code class="literal">substr</code>, or the empty string if <code class="literal">s</code> does not contain <code class="literal">substr</code>.</td></tr><tr><td align="left"><code class="literal">substringBeforeLast(s, substr)</code></td><td>Returns the substring of <code class="literal">s</code> before the last occurrence of <code class="literal">substr</code>, or the empty string if <code class="literal">s</code> does not contain <code class="literal">substr</code>.</td></tr><tr><td align="left"><code class="literal">substringAfterLast(s, substr)</code></td><td>Returns the substring of <code class="literal">s</code> after the last occurrence of <code class="literal">substr</code>, or the empty string if <code class="literal">s</code> does not contain <code class="literal">substr</code>.</td></tr><tr><td align="left"><code class="literal">startsWith(s, substr)</code></td><td>Returns true if <code class="literal">s</code> begins with the substring <code class="literal">substr</code>.</td></tr><tr><td align="left"><code class="literal">endsWith(s, substr)</code></td><td>Returns true if <code class="literal">s</code> ends with the substring <code class="literal">substr</code>.</td></tr><tr><td align="left"><code class="literal">tail(s, len)</code></td><td>Returns the last <code class="literal">len</code> character of <code class="literal">s</code>, or the full <code class="literal">s</code> if it is shorter than <code class="literal">len</code> characters.</td></tr><tr><td align="left"><code class="literal">replace(s, substr, repl, startPos?)</code></td><td>Replaces all occurrences of <code class="literal">substr</code> in <code class="literal">s</code> with the string repl.
            If <code class="literal">startPos</code> is given, search begins from position <code class="literal">startPos</code> in <code class="literal">s</code>.</td></tr><tr><td align="left"><code class="literal">replaceFirst(s, substr)</code></td><td>Replaces the first occurrence of <code class="literal">substr</code> in <code class="literal">s</code> with the string <code class="literal">repl</code>.
            If <code class="literal">startPos</code> is given, search begins from position <code class="literal">startPos</code> in <code class="literal">s</code>.</td></tr><tr><td align="left"><code class="literal">trim(s)</code></td><td>Discards whitespace from the start and end of <code class="literal">s</code>, and returns the result.</td></tr><tr><td align="left"><code class="literal">indexOf(s, substr)</code></td><td>Returns the position of the first occurrence of substring <code class="literal">substr</code> in <code class="literal">s</code>,
            or -1 if <code class="literal">s</code> does not contain <code class="literal">substr</code>.</td></tr><tr><td align="left"><code class="literal">choose(index, s)</code></td><td>Interprets <code class="literal">s</code> as a space-separated list, and returns the item at the given <code class="literal">index</code>.
            Negative and out-of-bounds indices cause an error.</td></tr><tr><td align="left"><code class="literal">toUpper(s)</code></td><td>Converts <code class="literal">s</code> to all uppercase, and returns the result.</td></tr><tr><td align="left"><code class="literal">toLower(s)</code></td><td>Converts <code class="literal">s</code> to all lowercase, and returns the result.</td></tr><tr><td align="left"><span class="emphasis"><em>Misc functions</em></span></td><td class="auto-generated"> </td></tr><tr><td align="left"><code class="literal">select(index, ...)</code></td><td>Returns the <code class="literal">index</code>th item from the rest of the argument list; numbering starts from 0.</td></tr><tr><td align="left"><code class="literal">locate(x, ...)</code></td><td>Returns the zero-based index of the first argument that is greater than or equal to <code class="literal">x</code>. If no such element,
            then it returns the number of elements (index of last element + 1). Example: <code class="literal">locate(42, 0,10,20,50,100) == 3</code></td></tr></tbody></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm6172"></a>Implicit conversions</h3></div></div></div><p>The value of an expression can be a boolean, a double, an integer, or a string.
    During the evaluation, values are converted to the expected types of functions and operators
    automatically. The rules of these conversions are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>when a double is expected, then string values are parsed; boolean values are
    converted to 1 (<code class="literal">true</code>), or 0 (<code class="literal">false</code>)</p></li><li class="listitem"><p>when an integer is expected, then values are converted to double and are rounded</p></li><li class="listitem"><p>when a boolean is expected, then 0 converted to <code class="literal">false</code>, anything else to <code class="literal">true</code>.
    String values are first converted to numeric, then to boolean.</p></li><li class="listitem"><p>when a string is expected, then numbers are converted to their decimal notation,
    booleans are converted to "0" or "1".</p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="idm6188"></a>Parsing ambiguities</h3></div></div></div><p>Expressions like <span class="emphasis"><em>a.b*c.d</em></span> can be parsed as a reference to the <span class="emphasis"><em>d</em></span> statistic of modules
    whose names matches the <span class="emphasis"><em>a.b*c</em></span> pattern, or as the product of <span class="emphasis"><em>a.b</em></span> and <span class="emphasis"><em>c.d</em></span>. The expression
    parser always prefers the first meaning, i.e. <span class="emphasis"><em>*</em></span> and <span class="emphasis"><em>?</em></span> characters are interpreted as part of
    the pattern. If you want to enter the product or conditional expression, you can add spaces around
    the operators. Patterns can not contain unquoted spaces, so the parse will be unambigous.
    </p>There is another ambiguity that arises from the use of simple names. If you use e.g. <span class="emphasis"><em>s</em></span>
    in an expression, it can refer a scalar or a variable. In this case the name is first tried to be
    resolved as a variable reference, and if it was unsuccessful, then as a statistic name. However
    quoted names (e.g. <span class="emphasis"><em>'s</em></span>') always refer to statistics.
    </div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch12s03.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="apas02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Project-Specific Extensions </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Computing Scalars</td></tr></table></div></body></html>
