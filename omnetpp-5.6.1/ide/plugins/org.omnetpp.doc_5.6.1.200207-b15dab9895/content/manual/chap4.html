<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <meta name="copyright" content="OpenSim Ltd.">
  <meta NAME="Author" CONTENT="Andras Varga">
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="STYLESHEET" href="../book.css"  type="text/css">
  <title>OMNeT++ - Simulation Manual</title>
</head>
<style type="text/css">
  hr.pgbr { color: #f5f5f5; margin-top: 40px; margin-bottom: 10px; }
  ul.dl { padding-left: 30px; text-indent: -30px; list-style: none; }
  pre { margin: 4px 8px 4px 2px; padding: 8px 10px; background:#fffff4; border: 1px solid #dddddd; }
  pre.ned { background:#f5fff5; border-left: 4px solid #ccffcc; }
  pre.msg { background:#f5fff5; border-left: 4px solid #ccffcc; }
  pre.cpp { background:#f5f5f5; border-left: 4px solid #ccccff; }
  pre.inifile { background:#fffff0; border-left: 4px solid #e5e533; }
  pre.filelisting { background:#f0f0f0; border-left: 4px solid #d9d9d9; }
  pre.commandline { background:#fffff0; border-left: 4px solid #606060; }
  td,th { text-align:left; vertical-align:top; border:1px solid; padding:3pt; border-color:#000000; }
  div.caption { margin-top: 10px; }
  a[href] { color: #202080; text-decoration: none; }
  a:visited { text-decoration: none; }
  # a:hover { text-decoration: underline; }

  table.matrix { display:inline-block; vertical-align: middle; position: relative; border: 0px; background:#ffffff; margin-left:8pt; margin-right:8pt; }
  table.matrix:before, table.matrix:after { content: ""; position: absolute; top: 0; border: 1px solid #000; width: 6px; height: 100%; }
  table.matrix:before { left: -6px; border-right: 0px; }
  table.matrix:after { right: -6px; border-left: 0px; }
  table.matrix td { padding: 5px; text-align: center; border: 0px; }

  a.headerlink { visibility: hidden; }
</style>
<body>

<p><hr><b><a href="chap3.html">[Prev]</A>&nbsp;<a href="chap5.html">[Next]</A>&nbsp;<a href="toc.html#toc_4.">[TOC]</a>&nbsp;<a href="usman.html">[Chapters]</a></b><hr></p><h1><a name="cha:simple-modules"/>4 Simple Modules<a class="headerlink" href="#cha:simple-modules" title="Permalink to this headline">¶</a></h1>
<!--module!simple-->

<p>
<i>Simple modules</i> are the active components in the model.
Simple modules are programmed in C++, using the OMNeT++ class
library. The following sections contain a short introduction
to discrete event simulation in general, explain how its concepts are
implemented in OMNeT++, and give an overview and practical advice
on how to design and code simple modules.

<p>
<h2><a name="sec:simple-modules:simulation-concepts"/>4.1 Simulation Concepts<a class="headerlink" href="#sec:simple-modules:simulation-concepts" title="Permalink to this headline">¶</a></h2>

<p>This section contains a very brief introduction into how discrete
event simulation (DES) works, in order to introduce terms we'll use
when explaining OMNeT++ concepts<!--simulation!concepts--> and
implementation.

<p>
<h3><a name="sec:simple-modules:discrete-event-simulation"/>4.1.1 Discrete Event Simulation<a class="headerlink" href="#sec:simple-modules:discrete-event-simulation" title="Permalink to this headline">¶</a></h3>

<p>A <i>discrete event system</i> is a system where state changes
(events<!--events-->) happen at discrete instances in time, and events take zero time
to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change takes
place in the system between the events. This is in contrast to
<i>continuous</i> systems where state changes are continuous.
Systems that can be viewed as discrete event systems can be modeled
using discrete event simulation<!--discrete event simulation-->, DES.

<p>For example, computer networks are usually viewed as discrete
event systems. Some of the events are:

<p><ul>
  <li> start of a packet transmission
  <li> end of a packet transmission
  <li> expiry of a retransmission timeout
</ul>

<p>This implies that between two events such as <i>start of a packet
transmission</i> and <i>end of a packet transmission</i>, nothing
interesting happens. That is, the packet's state remains <i>being
transmitted</i>. Note that the definition of &#8220;interesting&#8221; events and states always
depends on the intent and purposes of the modeler.
If we were interested in the transmission of individual bits, we would
have included something like <i>start of bit transmission</i> and
<i>end of bit transmission</i> among our events.

<p>
The time when events occur is often called <i>event timestamp</i>;
<!--event timestamp--> with OMNeT++ we use the term
<i>arrival time</i><!--arrival time--> (because in the class
library, the word &#8220;timestamp&#8221; is reserved for a user-settable
attribute in the event class). Time within the model is often called
<i>simulation time</i><!--simulation time-->, <i>model time</i>
<!--model!time--> or <i>virtual time</i><!--virtual time-->
as opposed to real time<!--real time--> or CPU time<!--CPU time-->
which refer to how long the simulation program has been running and
how much CPU time it has consumed.

<p>

<p><h3><a name="sec:simple-modules:event-loop"/>4.1.2 The Event Loop<a class="headerlink" href="#sec:simple-modules:event-loop" title="Permalink to this headline">¶</a></h3>

<p>Discrete event simulation maintains the set of future
events<!--future events--> in a data structure often called
FES<!--FES--> (Future Event Set) or FEL<!--FEL--> (Future Event List).
Such simulators usually work according to the following pseudocode:

<p><pre class="verbatim">
<i>initialize -- this includes building the model and</i>
              <i>inserting initial events to FES</i>

<i>while (FES not empty and simulation not yet complete)</i>
<i>{</i>
    <i>retrieve first event from FES</i>
    <i>t:= timestamp of this event</i>
    <b><i>process event</i></b>
    <i>(processing may insert new events in FES or delete existing ones)</i>
<i>}</i>
<i>finish simulation (write statistical results, etc.)</i>
</pre>

<p>
The initialization step usually builds the data structures
representing the simulation model, calls any user-defined
initialization code, and inserts initial events<!--initial events-->
into the FES<!--FES--> to ensure that the simulation can start. Initialization
strategies can differ considerably from one simulator to another.

<p>
The subsequent loop consumes events from the FES<!--FES--> and processes
them. Events are processed in strict timestamp order
to maintain causality, that is, to ensure that no current event may have
an effect on earlier events.

<p>Processing an event involves calls to user-supplied code. For example,
using the computer network simulation example, processing a &#8220;timeout
expired&#8221; event may consist of re-sending a copy of the network
packet, updating the retry count, scheduling another &#8220;timeout&#8221;
event, and so on. The user code may also remove events from the FES<!--FES-->,
for example when canceling timeouts.

<p>The simulation stops when there are no events left (this rarely happens
in practice), or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the user
will typically want to record statistics into output files.

<p>
<h3><a name="sec:simple-modules:events-in-opp"/>4.1.3 Events and Event Execution Order in OMNeT++<a class="headerlink" href="#sec:simple-modules:events-in-opp" title="Permalink to this headline">¶</a></h3>

<p>OMNeT++ uses messages<!--message--> to represent
events<!--events-->.<br><ul><font size=-1>[For all practical purposes. Note that there
is a class called <tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt> that <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> subclasses from,
but it is only used internal to the simulation kernel.]</font></ul>
Messages are represented by instances of the <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> class
and its subclasses. Messages are sent from one module to another -- this
means that the place where the &#8220;event will occur&#8221; is the
<i>message's destination module</i>, and the model time when the
event occurs is the <i>arrival time</i><!--arrival time--> of the
message. Events like &#8220;timeout expired&#8221; are implemented by the
module sending a message to itself.

<p>Events are consumed from the FES<!--FES--> in arrival time order, to
maintain causality. More precisely, given two messages, the following
rules apply:

<p><ol>
<li> The message with the <b>earlier arrival time</b> is executed
    first. If arrival times are equal,
<li> the one with the <b>higher scheduling priority</b> (smaller
    numeric value) is executed first. If priorities are the same,
<li> the one <b>scheduled/sent earlier</b> is executed first.
</ol>

<p><i>Scheduling priority</i><!--message!priority--> is a user-assigned integer
attribute of messages.

<p>

<p><h3><a name="sec:simple-modules:simulation-time"/>4.1.4 Simulation Time<a class="headerlink" href="#sec:simple-modules:simulation-time" title="Permalink to this headline">¶</a></h3>

<p>The current simulation time can be obtained with the <tt>simTime()</tt> function.

<p>Simulation time in OMNeT++ is represented by the C++ type <tt>simtime_t</tt>,
which is by default a typedef to the <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> class.
<tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> class stores simulation time in a 64-bit integer,
using decimal fixed-point representation. The resolution is controlled
by the <i>scale exponent</i> global configuration variable; that is,
<tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> instances have the same resolution. The exponent can be
chosen between -18 (attosecond resolution) and 0 (seconds).
Some exponents with the ranges they provide are shown in the following table.

<p><center>
  <table border>
<TR> <TD align=right>
    Exponent </TD> <TD align=right> Resolution </TD> <TD align=center> Approx. Range </TD></TR>
<TR> <TD align=right>      -18 </TD> <TD align=right> <i>10<sup>-18</sup></i>s (1as) </TD> <TD align=center> <i>+/- 9.22</i>s </TD></TR>
<TR> <TD align=right>      -15 </TD> <TD align=right> <i>10<sup>-15</sup></i>s (1fs) </TD> <TD align=center> <i>+/- 153.72</i> minutes </TD></TR>
<TR> <TD align=right>      -12 </TD> <TD align=right> <i>10<sup>-12</sup></i>s (1ps) </TD> <TD align=center> <i>+/- 106.75</i> days </TD></TR>
<TR> <TD align=right>      -9  </TD> <TD align=right> <i>10<sup>-9</sup></i>s (1ns)  </TD> <TD align=center> <i>+/- 292.27</i> years </TD></TR>
<TR> <TD align=right>      -6  </TD> <TD align=right> <i>10<sup>-6</sup></i>s (1us)  </TD> <TD align=center> <i>+/- 292271</i> years </TD></TR>
<TR> <TD align=right>      -3  </TD> <TD align=right> <i>10<sup>-3</sup></i>s (1ms)  </TD> <TD align=center> <i>+/- 2.9227e8</i> years </TD></TR>
<TR> <TD align=right>      0   </TD> <TD align=right> 1s                </TD> <TD align=center> <i>+/- 2.9227e11</i> years </TD></TR>
  </table>
</center>

<p>Note that although simulation time cannot be negative, it is still useful to
be able to represent negative numbers, because they often arise
during the evaluation of arithmetic expressions.

<p>There is no implicit conversion from <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> to <tt>double</tt>, mostly
because it would conflict with overloaded arithmetic operations of <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt>;
use the <tt>dbl()</tt> method of <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> or the <tt>SIMTIME_DBL()</tt> macro
to convert. To reduce the need for <tt>dbl()</tt>, several functions and methods
have overloaded variants that directly accept <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt>, for example
<tt>fabs()</tt>, <tt>fmod()</tt>, <tt>div()</tt>, <tt>ceil()</tt>, <tt>floor()</tt>,
<tt>uniform()</tt>, <tt>exponential()</tt>, and <tt>normal()</tt>.

<p>Other useful methods of <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> include <tt>str()</tt>,
which returns the value as a string; <tt>parse()</tt>, which converts a
string to <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt>; <tt>raw()</tt>, which returns the
underlying 64-bit integer; <tt>getScaleExp()</tt>, which returns the
global scale exponent; <tt>isZero()</tt>, which tests whether the
simulation time is 0; and <tt>getMaxTime()</tt>, which returns the maximum
simulation time that can be represented at the current scale exponent.
Zero and the maximum simulation time are also accessible
via the <tt>SIMTIME_ZERO</tt> and <tt>SIMTIME_MAX</tt> macros.

<pre class="cpp">
// 340 microseconds in the future, truncated to millisecond boundary
simtime_t timeout = (simTime() + <a href="../api/classomnetpp_1_1SimTime.html">SimTime</a>(340, SIMTIME_US)).trunc(SIMTIME_MS);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
   Converting a <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> to <tt>double</tt> may lose precision, because
   <tt>double</tt> only has a 52-bit mantissa.
   Earlier versions of OMNeT++ used <tt>double</tt> for the simulation
   time, but that caused problems in long simulations that relied on fine-grained timing,
   for example MAC protocols. Other problems were the accumulation of
   rounding errors, and non-associativity (often <i>(x+y)+z != x+(y+z)</i>, see
   ~[<a href="#bib-Goldberg91what">Goldberg91what</a>]) which meant that two <tt>double</tt> simulation
   times could not be reliably compared for equality.
</ul>

<p>
<h3><a name="sec:simple-modules:fes-implementation"/>4.1.5 FES Implementation<a class="headerlink" href="#sec:simple-modules:fes-implementation" title="Permalink to this headline">¶</a></h3>

<p>The implementation of the FES<!--FES--> is a crucial factor in the
performance of a discrete event simulator. In OMNeT++, the FES is
replaceable, and the default FES implementation uses <i>binary
heap</i><!--binary heap--> as data structure. Binary heap is generally
considered to be the best FES algorithm for discrete event simulation, as
it provides a good, balanced performance for most workloads. (Exotic data
structures like <i>skiplist</i><!--skiplist--> may perform better than
heap in some cases.)

<p>
<h2><a name="sec:simple-modules:simple-modules-in-opp"/>4.2 Components, Simple Modules, Channels<a class="headerlink" href="#sec:simple-modules:simple-modules-in-opp" title="Permalink to this headline">¶</a></h2>

<p>OMNeT++ simulation models are composed of modules and connections. Modules
may be simple (atomic) modules or compound modules; simple modules are the
active components in a model, and their behaviour is defined by the user as
C++ code. Connections may have associated channel objects. Channel objects
encapsulate channel behavior: propagation and transmission time modeling,
error modeling, and possibly others. Channels are also programmable in C++
by the user.

<p>Modules and channels are represented with the <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>
classes, respectively. <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt> are both
derived from the <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt> class.

<p>The user defines simple module types by subclassing <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>.
Compound modules are instantiated with <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>, although
the user can override it with <b><tt>@class</tt></b> in the NED file, and can even
use a simple module C++ class (i.e. one derived from <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>)
for a compound module.

<p>The <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>'s subclasses include the three built-in channel
types: <tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt>, <tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> and
<tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt>. The user can create new channel types
by subclassing <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt> or any other channel class.

<p>The following inheritance diagram illustrates the relationship
of the classes mentioned above.

<p>
  <center>
    <img src="component-inheritance.svg">
    <center><div class="caption"><i>Figure: Inheritance of component, module and channel classes</i></div></center>
  </center>

<p>
Simple modules and channels can be programmed by redefining certain
member functions, and providing your own code in them. Some of those
member functions are declared on <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>, the common base
class of channels and modules.

<p><tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt> has the following member functions meant for
redefining in subclasses:

<p><ul>
  <li> <tt>initialize()</tt>. This method is invoked after OMNeT++ has
    set up the network (i.e. created modules and connected them according
    to the definitions), and provides a place for initialization code;
  <li> <tt>finish()</tt> is called when the simulation has terminated
    successfully, and its recommended use is the recording of summary
    statistics.
</ul>

<p><tt>initialize()</tt> and <tt>finish()</tt>, together with <tt>initialize()</tt>'s
variants for multi-stage initialization, will be covered in detail in
section <a href="chap4.html#sec:simple-modules:initialize-and-finish">[4.3.3]</a>.

<p>In OMNeT++, events occur inside simple modules<!--module!simple-->.
Simple modules encapsulate C++ code that generates events and reacts to events,
implementing the behaviour of the module.

<p>To define the dynamic behavior of a simple module, one of the following
member functions need to be overridden:

<p><ul>
  <li> <tt>handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)</tt>. It
     is invoked with the message as parameter whenever the
     module receives a message. <tt>handleMessage()</tt> is
     expected to <i>process</i> the message, and then return.
     Simulation time never elapses inside <tt>handleMessage()</tt>
     calls, only between them.
  <li> <tt>activity()</tt> is started as a coroutine<br><ul><font size=-1>[Cooperatively
     scheduled thread, explained later.]</font></ul> at the beginning of the simulation, and
     it runs until the end of simulation (or until the function
     returns or otherwise terminates). Messages are obtained with
     <tt>receive()</tt> calls. Simulation time elapses inside
     <tt>receive()</tt> calls.
</ul>

<p>Modules written with <tt>activity()</tt> and <tt>handleMessage()</tt> can be
freely mixed within a simulation model. Generally, <tt>handleMessage()</tt>
should be preferred to <tt>activity()</tt>, due to scalability and other
practical reasons. The two functions will be described in detail in sections
<a href="chap4.html#sec:simple-modules:handlemessage">[4.4.1]</a> and <a href="chap4.html#sec:simple-modules:activity">[4.4.2]</a>,
including their advantages and disadvantages.

<p>The behavior of channels can also be modified by redefining member functions.
However, the channel API is slightly more complicated than that of simple
modules, so we'll describe it in a later section (<a href="chap4.html#sec:simple-modules:channels">[4.8]</a>).

<p>Last, let us mention <tt>refreshDisplay()</tt>, which is related to updating
the visual appearance of the simulation when run under a graphical user
interface. <tt>refreshDisplay()</tt> is covered in the chapter that deals
with simulation visualization (<a href="chap8.html#sec:graphics:refreshdisplay">[8.2]</a>).

<p><ul class="note"><b>NOTE</b><br>
    <tt>refreshDisplay()</tt> has been added in OMNeT++ 5.0. Until then,
    visualization-related tasks were usually implemented as part of
    <tt>handleMessage()</tt>. <tt>refreshDisplay()</tt> provides
    a far superior and more efficient solution.
</ul>

<p>
<h2><a name="sec:simple-modules:defining-simple-modules"/>4.3 Defining Simple Module Types<a class="headerlink" href="#sec:simple-modules:defining-simple-modules" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:defining:overview"/>4.3.1 Overview<a class="headerlink" href="#sec:simple-modules:defining:overview" title="Permalink to this headline">¶</a></h3>

<p>As mentioned before, a simple module<!--module!simple--> is nothing more
than a C++ class which has to be subclassed from <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>,
with one or more virtual member functions redefined to define its behavior.

<p>The class has to be registered with OMNeT++ via the <tt>Define_Module()</tt> macro.
The <tt>Define_Module()</tt> line should always be put into <tt>.cc</tt> or <tt>.cpp</tt>
files and not header file (<tt>.h</tt>), because the compiler generates code from it.

<p>The following <tt>HelloModule</tt> is about the simplest simple module one could write.
(We could have left out the <tt>initialize()</tt> method as well to make it even smaller,
but how would it say Hello then?) Note <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt> as base class,
and the <tt>Define_Module()</tt> line.

<pre class="cpp">
// file: HelloModule.cc
#include &lt;omnetpp.h&gt;
using namespace omnetpp;

class HelloModule : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

// register module class with OMNeT++
Define_Module(HelloModule);

void HelloModule::initialize()
{
    EV &lt;&lt; "Hello World!\n";
}

void HelloModule::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    delete msg; // just discard everything we receive
}
</pre>
<p>
In order to be able to refer to this simple<!--module!simple--> module type
in NED files, we also need an associated NED declaration which might
look like this:

<pre class="ned">
// file: HelloModule.ned
simple HelloModule
{
    gates:
        input in;
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:module-ctor"/>4.3.2 Constructor<a class="headerlink" href="#sec:simple-modules:module-ctor" title="Permalink to this headline">¶</a></h3>

<p>Simple modules are never instantiated by the user directly, but rather by
the simulation kernel. This implies that one cannot write arbitrary
constructors: the signature must be what is expected by the simulation kernel.
Luckily, this contract is very simple: the constructor must be public, and must take
no arguments:

<pre class="cpp">
  public:
    HelloModule();  // constructor takes no arguments
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt> itself has two constructors:
<ol>
  <li> <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>()</tt> -- one without arguments
  <li> <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>(size_t stacksize)</tt> -- one that accepts the coroutine
        stack size<!--module!stack size--><!--stack!size-->
</ol>

<p>The first version should be used with <tt>handleMessage()</tt> simple modules,
and the second one with <tt>activity()</tt> modules.
(With the latter, the <tt>activity()</tt> method of the module class
runs as a coroutine<!--coroutine--> which needs a separate CPU stack,
usually of 16..32K. This will be discussed in detail later.)
Passing zero stack size to the latter constructor also selects <tt>handleMessage()</tt>.

<p>Thus, the following constructor definitions are all OK, and select
<tt>handleMessage()</tt> to be used with the module:

<pre class="cpp">
HelloModule::HelloModule() {...}
HelloModule::HelloModule() : <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>() {...}
</pre>
<p>
It is also OK to omit the constructor altogether, because the
compiler-generated one is suitable too.

<p>The following constructor definition selects <tt>activity()</tt> to be used
with the module, with 16K of coroutine stack:

<pre class="cpp">
HelloModule::HelloModule() : <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>(16384) {...}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    The <tt>Module_Class_Members()</tt> macro, already deprecated in OMNeT++ 3.2,
    has been removed in the 4.0 version. When porting older simulation models,
    occurrences of this macro can simply be removed from the source code.
</ul>

<p>
<h3><a name="sec:simple-modules:initialize-and-finish"/>4.3.3 Initialization and Finalization<a class="headerlink" href="#sec:simple-modules:initialize-and-finish" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:init-finish:basic-usage"/>4.3.3.1 Basic Usage<a class="headerlink" href="#sec:simple-modules:init-finish:basic-usage" title="Permalink to this headline">¶</a></h4>

<p>The <tt>initialize()</tt> and <tt>finish()</tt> methods are declared
as part of <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>, and provide the user the opportunity
of running code at the beginning and at successful termination of the
simulation.

<p>The reason <tt>initialize()</tt> exists is that usually you cannot put
simulation-related code into the simple module
constructor<!--module!constructor-->, because the simulation model is still
being setup when the constructor runs, and many required objects are not yet
available. In contrast, <tt>initialize()</tt> is called just before the
simulation starts executing, when everything else has been set up
already.

<p><tt>finish()</tt> is for recording statistics, and it only gets called
when the simulation has terminated normally. It does not get called when
the simulations stops with an error message. The destructor always
gets called at the end, no matter how the simulation stopped, but
at that time it is fair to assume that the simulation model has been
halfway demolished already.

<p>Based on the above considerations, the following usage conventions exist
for these four methods:

<p><ul class="dl">

<p><li> Constructor:

<p>Set pointer members of the module class to <tt>nullptr</tt>; postpone all other
initialization tasks to <tt>initialize()</tt>.

<p><li> <tt>initialize()</tt>:

<p>Perform all initialization tasks: read module parameters, initialize
class variables, allocate dynamic data structures with <tt>new</tt>;
also allocate and initialize self-messages (timers) if needed.

<p><li> <tt>finish()</tt>:

<p>Record statistics. Do <b>not</b> <tt>delete</tt> anything or cancel timers --
all cleanup must be done in the destructor.

<p><li> Destructor:

<p>Delete everything which was allocated by <tt>new</tt> and is still held
by the module class. With self-messages (timers), use the
<tt>cancelAndDelete(msg)</tt> function! It is almost always wrong
to just delete a self-message from the destructor, because it might be
in the scheduled events list. The <tt>cancelAndDelete(msg)</tt> function
checks for that first, and cancels the message before deletion if necessary.

<p></ul>

<p>OMNeT++ prints the list of unreleased objects at the end of the simulation.
When a simulation model dumps <i>"undisposed object ..."</i> messages, this indicates
that the corresponding module destructors should be fixed. As a temporary measure, these
messages may be hidden by setting <tt>print-undisposed=false</tt> in the
configuration.

<p><ul class="note"><b>NOTE</b><br>
    The <tt>perform-gc</tt> configuration option has been removed in OMNeT++ 4.0.
    Automatic garbage collection cannot be implemented reliably, due to the
    limitations of the C++ language.
</ul>

<p>
<h4><a name="sec:simple-modules:init-finish:invocation-order"/>4.3.3.2 Invocation Order<a class="headerlink" href="#sec:simple-modules:init-finish:invocation-order" title="Permalink to this headline">¶</a></h4>

<p>The <tt>initialize()</tt> functions of the modules are invoked <i>before</i>
the first event is processed, but <i>after</i> the initial events (starter
messages<!--starter messages-->) have been placed into the FES<!--FES--> by
the simulation kernel.

<p>Both simple and compound modules have <tt>initialize()</tt> functions. A
compound module's <tt>initialize()</tt> function runs <i>before</i> that of
its submodules.

<p>The <tt>finish()</tt> functions are called when the event loop<!--event loop-->
has terminated, and only if it terminated normally.

<p><ul class="note"><b>NOTE</b><br>
<tt>finish()</tt> is not called if the simulation has terminated
with a runtime error.
</ul>

<p>The calling order for <tt>finish()</tt> is the reverse of the order of
<tt>initialize()</tt>: first submodules, then the encompassing compound module.
  <br><ul><font size=-1>[The way you can provide an <tt>initialize()</tt> function
  for a compound module is to subclass <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>, and tell
  OMNeT++ to use the new class for the compound module. The latter is done
  by adding the <tt>@class(&lt;classname&gt;)</tt> property into the NED declaration.]</font></ul>

<p>This is summarized in the following pseudocode:

<p>
<pre class="verbatim">
<i>perform simulation run:</i>
    build network
      (i.e. the system module and its submodules recursively)
    insert starter messages for all submodules using activity()
    do callInitialize() on system module
        <i>enter event loop // (described earlier)</i>
    if (event loop terminated normally) // i.e. no errors
        do callFinish() on system module
    clean up

callInitialize()
{
    call to user-defined initialize() function
    if (module is compound)
        for (each submodule)
            do callInitialize() on submodule
}

callFinish()
{
    if (module is compound)
        for (each submodule)
            do callFinish() on submodule
    call to user-defined finish() function
}
</pre>

<p>Keep in mind that <tt>finish()</tt> is not always called, so it isn't a
good place for cleanup code which should run every time the module is
deleted. <tt>finish()</tt> is only a good place for writing statistics,
result post-processing and other operations  which are supposed to run only on
successful completion. Cleanup code should go into the
destructor<!--module!destructor-->.

<p>
<h4><a name="sec:simple-modules:multi-stage-init"/>4.3.3.3 Multi-Stage Initialization<a class="headerlink" href="#sec:simple-modules:multi-stage-init" title="Permalink to this headline">¶</a></h4>

<p>In simulation models where one-stage
initialization<!--initialization--> provided by <tt>initialize()</tt>
is not sufficient, one can use multi-stage
initialization<!--initialization!multi-stage-->.  Modules have two
functions which can be redefined by the user:

<pre class="cpp">
virtual void initialize(int stage);
virtual int numInitStages() const;
</pre>
<p>
At the beginning of the simulation, <tt>initialize(0)</tt>
is called for <i>all</i> modules, then <tt>initialize(1)</tt>,
<tt>initialize(2)</tt>, etc. You can think of it like
initialization takes place in several &#8220;waves&#8221;. For each module,
<tt>numInitStages()</tt> must be redefined to return the number of init
stages required, e.g. for a two-stage init, <tt>numInitStages()</tt>
should return 2, and <tt>initialize(int stage)</tt> must be implemented to
handle the <i>stage=0</i> and <i>stage=1</i> cases.
  <br><ul><font size=-1>[Note the <tt>const</tt> in the <tt>numInitStages()</tt> declaration.
  If you forget it, by C++ rules you create a <i>different</i> function
  instead of redefining the existing one in the base class, thus the
  existing one will remain in effect and return 1.]</font></ul>

<p>The <tt>callInitialize()</tt> function performs the full multi-stage initialization
for that module and all its submodules.

<p>If you do not redefine the multi-stage initialization functions, the
default behavior is single-stage initialization: the default
<tt>numInitStages()</tt> returns 1, and the default <tt>initialize(int stage)</tt>
simply calls <tt>initialize()</tt>.

<p>
<h4><a name="sec:simple-modules:end-of-simulation-event"/>4.3.3.4 &#8220;End-of-Simulation&#8221; Event<a class="headerlink" href="#sec:simple-modules:end-of-simulation-event" title="Permalink to this headline">¶</a></h4>

<p>The task of <tt>finish()</tt> is implemented in several other simulators
by introducing a special <i>end-of-simulation</i><!--end-of-simulation--> event.
This is not a very good practice because the simulation programmer has to
code the models (often represented as FSMs) so that they can <i>always</i>
properly respond to end-of-simulation events, in whichever state they are. This
often makes program code unnecessarily complicated.
 For this reason OMNeT++ does not use the end of simulation event.

<p>This can also be witnessed in the design of the PARSEC<!--PARSEC-->
simulation language (UCLA). Its predecessor Maisie used
end-of-simulation events, but -- as documented in the PARSEC manual --
this has led to awkward programming in many cases, so for PARSEC
end-of-simulation events were dropped in favour of <tt>finish()</tt>
(called <tt>finalize()</tt> in PARSEC).

<p>
<h2><a name="sec:simple-modules:handlemessage-and-activity"/>4.4 Adding Functionality to <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a><a class="headerlink" href="#sec:simple-modules:handlemessage-and-activity" title="Permalink to this headline">¶</a></h2>

<p>This section discusses <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>'s previously mentioned
<tt>handleMessage()</tt> and <tt>activity()</tt> member functions, intended
to be redefined by the user.

<p>
<h3><a name="sec:simple-modules:handlemessage"/>4.4.1 handleMessage()<a class="headerlink" href="#sec:simple-modules:handlemessage" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:handlemessage:overview"/>4.4.1.1 Function Called for Each Event<a class="headerlink" href="#sec:simple-modules:handlemessage:overview" title="Permalink to this headline">¶</a></h4>

<p>The idea is that at each event<!--event--> (message arrival) we
simply call a user-defined function. This function,
<tt>handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)</tt> is a
virtual member function of <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt> which does
nothing by default -- the user has to redefine it in subclasses
and add the message processing code.

<p>The <tt>handleMessage()</tt> function will be called for every message
that arrives at the module. The function should process the message
and return immediately after that. The simulation time is potentially
different in each call. No simulation time elapses within a call
to <tt>handleMessage()</tt>.

<p>The event loop inside the simulator handles both <tt>activity()</tt>
and <tt>handleMessage()</tt> simple modules, and it corresponds
to the following pseudocode:

<p><pre class="verbatim">
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    m:= module containing this event
    if (m works with handleMessage())
        <b>m-&gt;handleMessage( event )</b>
    else // m works with activity()
        transferTo( m )
}
</pre>

<p>Modules with <tt>handleMessage()</tt> are NOT started automatically:
the simulation kernel creates starter messages<!--starter messages-->
only for modules with <tt>activity()</tt>. This means that you have to
schedule self-messages<!--self-message--> from the
<tt>initialize()</tt> function if you want a <tt>handleMessage()</tt>
simple module to start working &#8220;by itself&#8221;, without first receiving
a message from other modules.

<p>
<h4><a name="sec:simple-modules:handlemessage:programming"/>4.4.1.2 Programming with handleMessage()<a class="headerlink" href="#sec:simple-modules:handlemessage:programming" title="Permalink to this headline">¶</a></h4>

<p>To use the <tt>handleMessage()</tt> mechanism in a simple module, you must
specify <i>zero stack size</i><!--zero stack size--> for the module.
This is important, because this tells OMNeT++ that you want to use
<tt>handleMessage()</tt> and not <tt>activity()</tt>.

<p>Message/event related functions you can use in <tt>handleMessage()</tt>:

<p><ul>
  <li> <tt>send()</tt> family of functions -- to send messages to other modules
  <li> <tt>scheduleAt()</tt> -- to schedule an event (the module &#8220;sends a message to itself&#8221;)
  <li> <tt>cancelEvent()</tt> -- to delete an event scheduled with <tt>scheduleAt()</tt>
</ul>

<p>The <tt>receive()</tt> and <tt>wait()</tt> functions cannot be used in
<tt>handleMessage()</tt>, because they are coroutine-based by nature, as
explained in the section about <tt>activity()</tt>.

<p>You have to add data members to the module class for every piece
of information you want to preserve. This information cannot
be stored in local variables of <tt>handleMessage()</tt> because they
are destroyed when the function returns. Also, they cannot be
stored in static variables in the function (or the class), because
they would be shared between all instances of the class.

<p>Data members to be added to the module class will typically include
things like:

<p><ul>
  <li> state (e.g. IDLE/BUSY, CONN_DOWN/CONN_ALIVE/...)
  <li> other variables which belong to the state of the module: retry
    counts, packet queues, etc.
  <li> values retrieved/computed once and then stored: values of module
    parameters, gate indices, routing information, etc.
  <li> pointers of message objects created once and then reused for
    timers, timeouts, etc.
  <li> variables/objects for statistics collection
</ul>

<p>These variables are often initialized from the <tt>initialize()</tt>
method, because the information needed to obtain the initial value
(e.g. module parameters) may not yet be available at the time the
module constructor runs.

<p>Another task to be done in <tt>initialize()</tt> is to schedule
initial event(s)<!--events!initial--> which trigger the first call(s)
to <tt>handleMessage()</tt>.  After the first call,
<tt>handleMessage()</tt> must take care to schedule further events for
itself so that the &#8220;chain&#8221; is not broken. Scheduling events is not
necessary if your module only has to react to messages coming from
other modules.

<p><tt>finish()</tt> is normally used to record statistics information
accumulated in data members of the class at the end of the simulation.

<p>
<h4><a name="sec:simple-modules:handlemessage:application-area"/>4.4.1.3 Application Area<a class="headerlink" href="#sec:simple-modules:handlemessage:application-area" title="Permalink to this headline">¶</a></h4>

<p><tt>handleMessage()</tt> is in most cases a better choice than <tt>activity()</tt>:

<p><ol>
  <li> When you expect the module to be used in large simulations,
      involving several thousand modules. In such cases, the module stacks
      required by <tt>activity()</tt> would simply consume too much memory.
  <li> For modules which maintain little or no state information,
      such as packet sinks, <tt>handleMessage()</tt> is more convenient to program.
  <li> Other good candidates are modules with a large state space and
      many arbitrary state transition possibilities (i.e. where there
      are many possible subsequent states for any state). Such algorithms
      are difficult to program with <tt>activity()</tt>, and
      better suited for <tt>handleMessage()</tt> (see rule of thumb
      below). This is the case for most communication protocols.
</ol>

<p>
<h4><a name="sec:simple-modules:handlemessage:protocol-model-example"/>4.4.1.4 Example 1: Protocol Models<a class="headerlink" href="#sec:simple-modules:handlemessage:protocol-model-example" title="Permalink to this headline">¶</a></h4>

<p>Models of protocol layers in a communication network tend to have
a common structure on a high level because fundamentally they all have to react
to three types of events: to messages arriving from higher layer protocols
(or apps), to messages arriving from lower layer protocols (from the network),
and to various timers and timeouts (that is, self-messages).

<p>This usually results in the following source code pattern:

<pre class="cpp">
class FooProtocol : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    // state variables
    // ...

    virtual void processMsgFromHigherLayer(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *packet);
    virtual void processMsgFromLowerLayer(FooPacket *packet);
    virtual void processTimer(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *timer);

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

// ...

void FooProtocol::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    if (msg-&gt;isSelfMessage())
        processTimer(msg);
    else if (msg-&gt;arrivedOn("fromNetw"))
        processMsgFromLowerLayer(check_and_cast&lt;FooPacket *&gt;(msg));
    else
        processMsgFromHigherLayer(msg);
}
</pre>
<p>
The functions <tt>processMsgFromHigherLayer()</tt>, <tt>processMsgFromLowerLayer()</tt>
and <tt>processTimer()</tt> are then usually split further: there are separate
methods to process separate packet types and separate timers.

<p>
<h4><a name="sec:simple-modules:handlemessage:traffic-generator-example"/>4.4.1.5 Example 2: Simple Traffic Generators and Sinks<a class="headerlink" href="#sec:simple-modules:handlemessage:traffic-generator-example" title="Permalink to this headline">¶</a></h4>

<p>
The code for simple packet generators and sinks programmed with <tt>handleMessage()</tt> might
be as simple as the following pseudocode:

<pre class="cpp">
PacketGenerator::handleMessage(msg)
{
    create and send out a new packet;
    schedule msg again to trigger next call to handleMessage;
}

PacketSink::handleMessage(msg)
{
    delete msg;
}
</pre>
<p>
Note that <i>PacketGenerator</i> will need to redefine <tt>initialize()</tt>
to create <i>m</i> and schedule the first event.

<p>The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been
discussed yet, but the code is probably understandable nevertheless.)

<p>
<pre class="cpp">
class Generator : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  public:
    Generator() : <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>() {}
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

Define_Module(Generator);

void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>);
}

void Generator::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *pkt = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>;
    send(pkt, "out");
    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</pre>

<p>

<p><h4><a name="sec:simple-modules:handlemessage:bursty-trafgen-example"/>4.4.1.6 Example 3: Bursty Traffic Generator<a class="headerlink" href="#sec:simple-modules:handlemessage:bursty-trafgen-example" title="Permalink to this headline">¶</a></h4>

<p>A bit more realistic example is to rewrite our Generator to create
packet bursts, each consisting of <tt>burstLength</tt> packets.

<p>We add some data members to the class:
<ul>
<li> <tt>burstLength</tt> will store the parameter that specifies how many
    packets a burst must contain,
<li> <tt>burstCounter</tt> will count in how many packets are left to be sent
    in the current burst.
</ul>

<p>The code:

<pre class="cpp">
class BurstyGenerator : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    int burstLength;
    int burstCounter;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burstLength = par("burstLength");
    burstCounter = burstLength;
    // schedule first packet of first burst
    scheduleAt(simTime(), new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>);
}

void BurstyGenerator::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *pkt = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>;
    send(pkt, "out");
    // if this was the last packet of the burst
    if (--burstCounter == 0) {
        // schedule next burst
        burstCounter = burstLength;
        scheduleAt(simTime()+exponential(5.0), msg);
    }
    else {
        // schedule next sending within burst
        scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</pre>
<p>

<p>
<h4><a name="sec:simple-modules:handlemessage:pros-and-cons"/>4.4.1.7 Pros and Cons of Using <tt>handleMessage()</tt><a class="headerlink" href="#sec:simple-modules:handlemessage:pros-and-cons" title="Permalink to this headline">¶</a></h4>

<p>Pros:
<ul>
  <li> consumes less memory: no separate stack needed for simple modules
  <li> fast: function call is faster than switching between coroutines<!--coroutine-->
</ul>

<p>Cons:
<ul>
  <li> local variables cannot be used to store state information
  <li> need to redefine <tt>initialize()</tt>
</ul>

<p>Usually, <tt>handleMessage()</tt> should be preferred over <tt>activity()</tt>.

<p>
<h4><a name="sec:simple-modules:handlemessage:other-simulators"/>4.4.1.8 Other Simulators<a class="headerlink" href="#sec:simple-modules:handlemessage:other-simulators" title="Permalink to this headline">¶</a></h4>

<p>Many simulation packages use a similar approach, often topped with
something like a state machine<!--finite state machine-->
(FSM<!--FSM-->) which hides the underlying function calls. Such
systems are:
<ul>
  <li> OPNET<i><sup>TM</sup></i> which uses FSM's designed using a graphical editor;
  <li> NetSim++ clones OPNET's approach;
  <li> SMURPH (University of Alberta) defines a (somewhat eclectic)
      language to describe FSMs, and uses a precompiler to turn it
      into C++ code;
  <li> Ptolemy (UC Berkeley) uses a similar method.
</ul>

<p>OMNeT++'s FSM<!--FSM--> support is described in the next section.

<p>

<p><h3><a name="sec:simple-modules:activity"/>4.4.2 activity()<a class="headerlink" href="#sec:simple-modules:activity" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:activity:overview"/>4.4.2.1 Process-Style Description<a class="headerlink" href="#sec:simple-modules:activity:overview" title="Permalink to this headline">¶</a></h4>

<p>With <tt>activity()</tt>, a simple module can be coded much like an
operating system process or thread. One can wait for an incoming message
(event) at any point of the code, suspend the execution for some time
(model time!), etc. When the <tt>activity()</tt> function exits, the module
is terminated.  (The simulation can continue if there are other modules
which can run.)

<p>The most important functions that can be used in <tt>activity()</tt> are
(they will be discussed in detail later):
<ul>
<li> <tt>receive()</tt> -- to receive messages (events)
<li> <tt>wait()</tt> -- to suspend execution<!--suspend execution-->
    for some time (model time)
<li> <tt>send()</tt> family of functions -- to send messages to other
    modules
<li> <tt>scheduleAt()</tt> -- to schedule an event (the module &#8220;sends
    a message to itself&#8221;)
<li> <tt>cancelEvent()</tt> -- to delete an event scheduled with
    <tt>scheduleAt()</tt>
<li> <tt>end()</tt> -- to finish execution of this module (same as
    exiting the <tt>activity()</tt> function)
</ul>

<p>The <tt>activity()</tt> function normally contains an infinite loop,
with at least a <tt>wait()</tt> or <tt>receive()</tt> call in its body.

<p>

<p><h4><a name="sec:simple-modules:activity:application-area"/>4.4.2.2 Application Area<a class="headerlink" href="#sec:simple-modules:activity:application-area" title="Permalink to this headline">¶</a></h4>

<p>Generally you should prefer <tt>handleMessage()</tt> to <tt>activity()</tt>.
The main problem with <tt>activity()</tt> is that it doesn't scale because
every module needs a separate coroutine stack. It has also been observed
that <tt>activity()</tt> does not encourage a good programming style, and
stack switching also confuses many debuggers.

<p>There is one scenario where <tt>activity()</tt>'s process-style
description is convenient: when the process has many
states but transitions are very limited, i.e. from any state the
process can only go to one or two other states.  For example, this is
the case when programming a network application, which uses a single
network connection.  The pseudocode of the application which talks to
a transport layer protocol might look like this:

<p><pre class="verbatim">
<i>activity()</i>
{
    while(true)
    {
        open connection by sending OPEN command to transport layer
        receive reply from transport layer
        if (open not successful)
        {
            wait(some time)
            continue // loop back to while()
        }

        while (there is more to do)
        {
            send data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
            receive data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
        }
        close connection by sending CLOSE command to transport layer
        if (close not successful)
        {
            // handle error
        }
        wait(some time)
    }
}
</pre>

<p>If there is a need to handle several connections concurrently, dynamically creating
simple modules to handle each is an option. Dynamic module creation will be discussed
later.

<p>There are situations when you certainly <i>do not want</i> to use <tt>activity()</tt>.
If the <tt>activity()</tt> function contains no <tt>wait()</tt> and it has only one
<tt>receive()</tt> at the top of a message handling loop, there is no point in
using <tt>activity()</tt>, and the code should be written with <tt>handleMessage()</tt>.
The body of the loop would then become the body of <tt>handleMessage()</tt>,
state variables inside <tt>activity()</tt> would become data members in
the module class, and they would be initialized in <tt>initialize()</tt>.

<p>Example:

<pre class="cpp">
void Sink::activity()
{
    while(true) {
        msg = receive();
        delete msg;
    }
}
</pre>
<p>
should rather be programmed as:

<pre class="cpp">
void Sink::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    delete msg;
}
</pre>
<p>

<p>
<h4><a name="sec:simple-modules:activity:coroutine"/>4.4.2.3 Activity() Is Run as a Coroutine<a class="headerlink" href="#sec:simple-modules:activity:coroutine" title="Permalink to this headline">¶</a></h4>

<p><tt>activity()</tt> is run in a coroutine<!--coroutine-->.
Coroutines are similar to threads, but are scheduled
non-preemptively (this is also called cooperative
multitasking<!--multitasking!cooperative-->).
One can switch from one coroutine to another coroutine by a
<tt>transferTo(otherCoroutine)</tt> call, causing the first coroutine
to be suspended and second one to run. Later, when the
second coroutine performs a <tt>transferTo(firstCoroutine)</tt> call
to the first one, the execution of the first coroutine will resume
from the point of the <tt>transferTo(otherCoroutine)</tt> call.
The full state of the coroutine, including local variables are preserved while the
thread of execution is in other coroutines.  This implies that each
coroutine has its own CPU stack<!--stack-->, and
<tt>transferTo()</tt> involves a switch from one CPU stack to
another.

<p>Coroutines<!--coroutine--> are at the heart of OMNeT++, and the
simulation programmer doesn't ever need to call <tt>transferTo()</tt>
or other functions in the coroutine library, nor does he need to care
about the coroutine library implementation. It is important to
understand, however, how the event loop found in discrete event simulators
works with coroutines.

<p>When using coroutines, the event loop<!--event loop--> looks like
this (simplified):

<p>
<pre class="verbatim">
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    <b>transferTo(module containing the event)</b>
}
</pre>

<p>

<p>That is, when a module has an event<!--event-->, the simulation
kernel transfers the control to the module's coroutine. It is expected
that when the module &#8220;decides it has finished the processing of the
event&#8221;, it will transfer the control back to the simulation kernel by
a <tt>transferTo(main)</tt> call. Initially,
simple<!--module!simple--> modules using <tt>activity()</tt> are
&#8220;booted&#8221; by events (<i>''starter messages''</i><!--starter messages-->)
inserted into the FES<!--FES--> by the simulation kernel before the
start of the simulation.

<p>
How does the coroutine know it has &#8220;finished processing the event&#8221;?
The answer: <i>when it requests another event</i>.  The functions
which request events from the simulation kernel are the
<tt>receive()</tt> and <tt>wait()</tt>, so their
implementations contain a <tt>transferTo(main)</tt> call
somewhere.

<p>
Their pseudocode, as implemented in OMNeT++:

<p>
<pre class="verbatim">
receive()
{
    transferTo(main)
    retrieve current event
    return the event // remember: events = messages
}

wait()
{
    create event e
    schedule it at (current sim. time + wait interval)
    transferTo(main)
    retrieve current event
    if (current event is not e) {
        error
    }
    delete e  // note: actual impl. reuses events
    return
}
</pre>

<p>

<p>Thus, the <tt>receive()</tt> and <tt>wait()</tt> calls are
special points in the <tt>activity()</tt> function, because
they are where

<p><ul>
  <li> simulation time elapses in the module, and
  <li> other modules get a chance to execute.
</ul>

<p>
<h4><a name="simple-modules:activity:starter-messages"/>4.4.2.4 Starter Messages<a class="headerlink" href="#simple-modules:activity:starter-messages" title="Permalink to this headline">¶</a></h4>

<p>Modules written with <tt>activity()</tt> need starter
messages<!--starter messages--> to &#8220;boot&#8221;.  These starter messages
are inserted into the FES<!--FES--> automatically by OMNeT++ at the
beginning of the simulation, even before the <tt>initialize()</tt>
functions are called.

<p>
<h4><a name="sec:simple-modules:activity:stack-size"/>4.4.2.5 Coroutine Stack Size<a class="headerlink" href="#sec:simple-modules:activity:stack-size" title="Permalink to this headline">¶</a></h4>

<p>The simulation programmer needs to define the CPU stack size<!--coroutine!stack size-->
for coroutines. This cannot be automated.

<p>16 or 32 kbytes is usually a good choice, but more space may be needed
if the module uses recursive functions or has many/large local variables.
OMNeT++ has a built-in mechanism that will usually detect if the module stack
is too small and overflows<!--stack!overflow-->. OMNeT++ can also report how
much stack space a module actually uses<!--stack!usage--> at runtime.

<p>
<h4><a name="sec:simple-modules:activity:initialize-and-finish"/>4.4.2.6 initialize() and finish() with activity()<a class="headerlink" href="#sec:simple-modules:activity:initialize-and-finish" title="Permalink to this headline">¶</a></h4>

<p>Because local variables of <tt>activity()</tt> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of the
<tt>activity()</tt> function, so there isn't much need to use
<tt>initialize()</tt>.

<p>You do need <tt>finish()</tt>, however, if you want to write statistics at
the end of the simulation. Because <tt>finish()</tt> cannot access
the local variables of <tt>activity()</tt>, you have to put the variables
and objects containing the statistics into the module class.
You still don't need <tt>initialize()</tt> because class members can also
be initialized at the top of <tt>activity()</tt>.

<p>Thus, a typical setup looks like this in pseudocode:

<p><pre class="verbatim">
<i>class MySimpleModule...</i>
{
    ...
    variables for statistics collection
    activity();
    finish();
};

MySimpleModule::activity()
{
    declare local vars and initialize them
    initialize statistics collection variables

    while(true)
    {
        ...
    }
}

MySimpleModule::finish()
{
    record statistics into file
}
</pre>

<p>
<h4><a name="sec:simple-modules:activity:pros-and-cons"/>4.4.2.7 Pros and Cons of Using <tt>activity()</tt><a class="headerlink" href="#sec:simple-modules:activity:pros-and-cons" title="Permalink to this headline">¶</a></h4>

<p>Pros:
<ul>
   <li> <tt>initialize()</tt> not needed, state can be stored in local
       variables of <tt>activity()</tt>
   <li> process-style description is a natural programming model in some cases
</ul>

<p>Cons:
<ul>
   <li> limited scalability: coroutine stacks can unacceptably increase the
       memory requirements of the simulation program if there are many
       <tt>activity()</tt>-based simple modules;
   <li> run-time overhead: switching between coroutines is slower than
       a simple function call
   <li> does not encourage a good programming style: as module complexity
       grows, <tt>activity()</tt> tends to become a large, monolythic function.
</ul>

<p>In most cases, cons outweigh pros and it is a better idea to use
<tt>handleMessage()</tt> instead.

<p>
<h4><a name="sec:simple-modules:activity:other-simulators"/>4.4.2.8 Other Simulators<a class="headerlink" href="#sec:simple-modules:activity:other-simulators" title="Permalink to this headline">¶</a></h4>

<p>Coroutines are used by a number of other simulation packages:
<ul>
<li> All simulation software which inherits from SIMULA (e.g. C++SIM)
    is based on coroutines, although all in all the programming
    model is quite different.
<li> The simulation/parallel programming language Maisie and its successor
    PARSEC (from UCLA) also use coroutines (although implemented
    with &#8220;normal&#8221; preemptive threads). The philosophy
    is quite similar to OMNeT++. PARSEC, being &#8220;just&#8221;
    a programming language, it has a more elegant syntax but far fewer
    features than OMNeT++.
<li> Many Java-based simulation libraries are based on Java
    threads.
</ul>

<p><h3><a name="sec:simple-modules:global-vars"/>4.4.3 How to Avoid Global Variables<a class="headerlink" href="#sec:simple-modules:global-vars" title="Permalink to this headline">¶</a></h3>
<!--global variables-->

<p>If possible, avoid using global variables, including
static class members. They are prone to cause several problems.
First, they are not reset to their initial values (to zero)
when you rebuild the simulation in Tkenv/Qtenv, or start another run
in Cmdenv. This may produce surprising results.
Second, they prevent you from parallelizing the simulation.
When using parallel simulation, each partition of the model
runs in a separate process, having their own copies of
global variables. This is usually not what you want.

<p>The solution is to encapsulate the variables into simple modules
as private or protected data members, and expose them via public methods.
Other modules can then call these public methods to get or set the values.
Calling methods of other modules will be discussed in section
<a href="chap4.html#sec:simple-modules:direct-method-calls">[4.12]</a>.
Examples of such modules are the <tt>Blackboard</tt> in the <i>Mobility Framework</i>,
and <tt>InterfaceTable</tt> and <tt>RoutingTable</tt> in the <i>INET Framework</i>.

<p>
<h3><a name="sec:simple-modules:module-subclassing"/>4.4.4 Reusing Module Code via Subclassing<a class="headerlink" href="#sec:simple-modules:module-subclassing" title="Permalink to this headline">¶</a></h3>

<p>The code of simple modules can be reused via subclassing, and redefining
virtual member functions. An example:

<pre class="cpp">
class TransportProtocolExt : public TransportProtocol
{
  protected:
    virtual void recalculateTimeout();
};

Define_Module(TransportProtocolExt);

void TransportProtocolExt::recalculateTimeout()
{
    //...
}
</pre>
<p>
The corresponding NED declaration:

<pre class="ned">
simple TransportProtocolExt extends TransportProtocol
{
    @class(TransportProtocolExt);  // Important!
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Note the <tt>@class()</tt> property, which tells OMNeT++ to use the
  <tt>TransportProtocolExt</tt> C++ class for the module type! It is needed
  because NED inheritance is NED inheritance <i>only</i>, so without <tt>@class()</tt>
  the <tt>TransportProtocolExt</tt> NED type would inherit the C++ class from
  its base NED type.
</ul>

<p>

<p><h2><a name="sec:simple-modules:parameters"/>4.5 Accessing Module Parameters<a class="headerlink" href="#sec:simple-modules:parameters" title="Permalink to this headline">¶</a></h2>

<p>Module parameters declared in NED files are represented with the <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt>
class at runtime, and be accessed<!--module!accessing parameters-->
by calling the <tt>par()</tt> member function of <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPar.html">cPar</a>& delayPar = par("delay");
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt>'s value can be read with methods that correspond to
the parameter's NED type: <tt>boolValue()</tt>, <tt>longValue()</tt>,
<tt>doubleValue()</tt>, <tt>stringValue()</tt>, <tt>stdstringValue()</tt>,
<tt>xmlValue()</tt>.
There are also overloaded type cast operators for the corresponding types
(<tt>bool</tt>; integer types including <tt>int</tt>, <tt>long</tt>, etc;
<tt>double</tt>; <tt>const char *</tt>; <tt><a href="../api/classomnetpp_1_1cXMLElement.html">cXMLElement</a> *</tt>).

<pre class="cpp">
long numJobs = par("numJobs").longValue();
double processingDelay = par("processingDelay"); // using operator double()
</pre>
<p>
Note that <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt> has two methods for returning a string value:
<tt>stringValue()</tt>, which returns <tt>const char *</tt>, and
<tt>stdstringValue()</tt>, which returns <tt>std::string</tt>.
For volatile parameters, only <tt>stdstringValue()</tt> may be used,
but otherwise the two are interchangeable.

<p>If you use the <tt>par("foo")</tt> parameter in expressions (such as
<tt>4*par("foo")+2</tt>), the C++ compiler may be unable to decide
between overloaded operators and report ambiguity. This issue can be
resolved by adding an explicit cast such as <tt>(double)par("foo")</tt>,
or using the <tt>doubleValue()</tt> or <tt>longValue()</tt> methods.

<p>
<h3><a name="sec:simple-modules:volatile-parameters"/>4.5.1 Volatile and Non-Volatile Parameters<a class="headerlink" href="#sec:simple-modules:volatile-parameters" title="Permalink to this headline">¶</a></h3>

<p>A parameter can be declared <tt>volatile</tt> in the NED file. The <tt>volatile</tt>
modifier indicates that a parameter is re-read every time a value is needed
during simulation. Volatile parameters typically are used for things like
random packet generation interval, and are assigned values like <tt>exponential(1.0)</tt>
(numbers drawn from the exponential distribution with mean 1.0).

<p>In contrast, non-volatile NED parameters are constants, and reading their
values multiple times is guaranteed to yield the same value. When a non-volatile
parameter is assigned a random value like <tt>exponential(1.0)</tt>, it is
evaluated once at the beginning of the simulation and replaced with the result,
so all reads will get same (randomly generated) value.

<p>The typical usage for non-volatile parameters is to read them in the
<tt>initialize()</tt> method of the module class, and store the values
in class variables for easy access later:

<pre class="cpp">
class Source : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    long numJobs;
    virtual void initialize();
    ...
};

void Source::initialize()
{
    numJobs = par("numJobs");
    ...
}
</pre>
<p>
<tt>volatile</tt> parameters need to be re-read every time the value is needed.
For example, a parameter that represents a random packet generation interval
may be used like this:

<pre class="cpp">
void Source::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    ...
    scheduleAt(simTime() + par("interval").doubleValue(), timerMsg);
    ...
}
</pre>
<p>
This code looks up the the parameter by name every time. This lookup
can be avoided by storing the parameter object's pointer in a class variable,
resulting in the following code:

<pre class="cpp">
class Source : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classomnetpp_1_1cPar.html">cPar</a> *intervalp;
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
    ...
};

void Source::initialize()
{
    intervalp = &par("interval");
    ...
}

void Source::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    ...
    scheduleAt(simTime() + intervalp-&gt;doubleValue(), timerMsg);
    ...
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:setting-parameters"/>4.5.2 Changing a Parameter's Value<a class="headerlink" href="#sec:simple-modules:setting-parameters" title="Permalink to this headline">¶</a></h3>

<p>Parameter values can be changed from the program, during execution.
This is rarely needed, but may be useful for some scenarios.

<p><ul class="note"><b>NOTE</b><br>
    The parameter's type cannot be changed at runtime -- it must
    remain the type declared in the NED file. It is also not possible
    to add or remove module parameters at runtime.
</ul>

<p>The methods to set the parameter value are <tt>setBoolValue()</tt>,
<tt>setLongValue()</tt>, <tt>setStringValue()</tt>,
<tt>setDoubleValue()</tt>, <tt>setXMLValue()</tt>. There are also
overloaded assignment operators for various types including <tt>bool</tt>,
<tt>int</tt>, <tt>long</tt>, <tt>double</tt>, <tt>const char *</tt>, and
<tt><a href="../api/classomnetpp_1_1cXMLElement.html">cXMLElement</a> *</tt>.

<p>To allow a module to be notified about parameter changes, override
its <tt>handleParameterChange()</tt> method, see
<a href="chap4.html#sec:simple-modules:handleparameterchange">[4.5.5]</a>.

<p>
<h3><a name="sec:simple-modules:further-cpar-methods"/>4.5.3 Further <a href="../api/classomnetpp_1_1cPar.html">cPar</a> Methods<a class="headerlink" href="#sec:simple-modules:further-cpar-methods" title="Permalink to this headline">¶</a></h3>

<p>The parameter's name and type are returned by the <tt>getName()</tt> and
<tt>getType()</tt> methods. The latter returns a value from an enum,
which can be converted to a readable string with the <tt>getTypeName()</tt>
static method. The enum values are <tt>BOOL</tt>, <tt>DOUBLE</tt>, <tt>LONG</tt>,
<tt>STRING</tt> and <tt>XML</tt>; and since the enum is an inner type,
they usually have to be qualified with <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a>::</tt>.

<p><tt>isVolatile()</tt> returns whether the parameter was declared volatile
in the NED file. <tt>isNumeric()</tt> returns true if the parameter
type is double or long.

<p>The <tt>str()</tt> method returns the parameter's value in a string form.
If the parameter contains an expression, then the string representation
of the expression is returned.

<p>An example usage of the above methods:

<pre class="cpp">
int n = getNumParams();
for (int i = 0; i &lt; n; i++)
{
    <a href="../api/classomnetpp_1_1cPar.html">cPar</a>& p = par(i);
    EV &lt;&lt; "parameter: " &lt;&lt; p.getName() &lt;&lt; "\n";
    EV &lt;&lt; "  type:" &lt;&lt; <a href="../api/classomnetpp_1_1cPar.html">cPar</a>::getTypeName(p.getType()) &lt;&lt; "\n";
    EV &lt;&lt; "  contains:" &lt;&lt; p.str() &lt;&lt; "\n";
}
</pre>
<p>
The NED properties of a parameter can be accessed with the <tt>getProperties()</tt>
method that returns a pointer to the <tt><a href="../api/classomnetpp_1_1cProperties.html">cProperties</a></tt> object that stores
the properties of this parameter. Specifically, <tt>getUnit()</tt> returns
the unit of measurement associated with the parameter (<b><tt>@unit</tt></b> property in NED).

<p>Further <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt> methods and related classes like <tt><a href="../api/classomnetpp_1_1cExpression.html">cExpression</a></tt> and
<tt><a href="../api/classomnetpp_1_1cDynamicExpression.html">cDynamicExpression</a></tt> are used by the NED infrastructure to set up and
assign parameters. They are documented in the <b>API Reference</b>, but
they are normally of little interest to users.

<p>
<h3><a name="sec:simple-modules:emulating-parameter-arrays"/>4.5.4 Emulating Parameter Arrays<a class="headerlink" href="#sec:simple-modules:emulating-parameter-arrays" title="Permalink to this headline">¶</a></h3>

<p>As of version 4.2, OMNeT++ does not support parameter arrays,
but in practice they can be emulated using string parameters.
One can assign the parameter a string which contains all values
in a textual form (for example, <tt>"0 1.234 3.95 5.467"</tt>), then
parse this string in the simple module.

<p>The <tt><a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a></tt> class can be quite useful for this
purpose. The constructor accepts a string, which it regards as
a sequence of tokens (words) separated by delimiter characters
(by default, spaces). Then you can either enumerate the tokens
and process them one by one (<tt>hasMoreTokens()</tt>, <tt>nextToken()</tt>),
or use one of the <tt><a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a></tt> convenience methods to convert
them into a vector of strings (<tt>asVector()</tt>), integers (<tt>asIntVector()</tt>),
or <tt>double</tt>s (<tt>asDoubleVector()</tt>).

<p>The latter methods can be used like this:

<pre class="cpp">
const char *vstr = par("v").stringValue(); // e.g. "aa bb cc";
std::vector&lt;std::string&gt; v = <a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a>(vstr).asVector();
</pre>
<p>
and

<pre class="cpp">
const char *str = "34 42 13 46 72 41";
std::vector&lt;int&gt; v = <a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a>().asIntVector();

const char *str = "0.4311 0.7402 0.7134";
std::vector&lt;double&gt; v = <a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a>().asDoubleVector();
</pre>
<p>
The following example processes the string by enumerating the tokens:

<pre class="cpp">
const char *str = "3.25 1.83 34 X 19.8"; // input

std::vector&lt;double&gt; result;
<a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a> tokenizer(str);
while (tokenizer.hasMoreTokens())
{
    const char *token = tokenizer.nextToken();
    if (strcmp(token, "X")==0)
        result.push_back(DEFAULT_VALUE);
    else
        result.push_back(atof(token));
}
</pre>
<p>
<h3><a name="sec:simple-modules:handleparameterchange"/>4.5.5 handleParameterChange()<a class="headerlink" href="#sec:simple-modules:handleparameterchange" title="Permalink to this headline">¶</a></h3>

<p>It is possible for modules to be notified when the value of a
parameter changes at runtime, possibly due to another module
dynamically changing it. A typical use is to re-read the changed
parameter, and update the module's state if needed.

<p>To enable notification, redefine the <tt>handleParameterChange()</tt> method
of the module class. This method will be called back by the
simulation kernel when a module parameter changes, <i>except during
initialization of the given module</i>.

<p><ul class="note"><b>NOTE</b><br>
  Notifications are disabled during the initialization of the component,
  because they would make it very difficult to write components
  that work reliably under all conditions.
  <tt>handleParameterChange()</tt> is usually triggered from another
  module (it does not make much sense for a module to change
  its own parameters), so the relative order of
  <tt>initialize()</tt> and <tt>handleParameterChange()</tt>
  would be effectively determined by the initialization order
  of modules, which generally cannot be relied upon. After the last
  stage of the initialization of the component is finished,
  <tt>handleParameterChange()</tt> is called by the simulation kernel
  with <tt>nullptr</tt> as a parameter name. This allows the component
  to react to parameter changes that occurred during the initialization phase.
</ul>

<p>The method signature is the following:

<pre class="cpp">
void handleParameterChange(const char *parameterName);
</pre>
<p>
The following example shows a module that re-reads
its <tt>serviceTime</tt> parameter when its value changes:

<pre class="cpp">
void Queue::handleParameterChange(const char *parname)
{
    if (strcmp(parname, "serviceTime")==0)
        serviceTime = par("serviceTime"); // refresh data member
}
</pre>
<p>
If your code heavily depends on notifications and you would like to
receive notifications during initialization or finalization as well, one
workaround is to explicitly call <tt>handleParameterChange()</tt>
from the <tt>initialize()</tt> or <tt>finish()</tt> function:

<pre class="cpp">
for (int i = 0; i &lt; getNumParams(); i++)
    handleParameterChange(par(i).getName());
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Be extremely careful when changing parameters from inside
  <tt>handleParameterChange()</tt>, because it is easy to accidentally
  create an infinite notification loop.
</ul>

<p>
<h2><a name="sec:simple-modules:gates"/>4.6 Accessing Gates and Connections<a class="headerlink" href="#sec:simple-modules:gates" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:gate-objects"/>4.6.1 Gate Objects<a class="headerlink" href="#sec:simple-modules:gate-objects" title="Permalink to this headline">¶</a></h3>

<p>Module gates<!--gate--> are represented by <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> objects.
Gate objects know to which other gates they are connected, and
what are the channel objects associated with the links.

<p><h4><a name="sec:simple-modules:accessing-gates-by-name"/>4.6.1.1 Accessing Gates by Name<a class="headerlink" href="#sec:simple-modules:accessing-gates-by-name" title="Permalink to this headline">¶</a></h4>

<p>The <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> class has a number of member functions that
deal with gates. You can look up a gate by name using the <tt>gate()</tt>
method:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *outGate = gate("out");
</pre>
<p>
This works for input and output gates. However, when a gate was declared
<tt>inout</tt> in NED, it is actually represented by the simulation kernel
with two gates, so the above call would result in a <i>gate not found</i>
error. The <tt>gate()</tt> method needs to be told whether the input or
the output half of the gate you need. This can be done by appending
the <tt>"$i"</tt> or <tt>"$o"</tt> to the gate name. The following example
retrieves the two gates for the inout gate <tt>"g"</tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gIn = gate("g$i");
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gOut = gate("g$o");
</pre>
<p>
Another way is to use the <tt>gateHalf()</tt> function, which takes
the inout gate's name plus either <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INPUT</tt> or <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT</tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gIn = gateHalf("g", <a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INPUT);
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gOut = gateHalf("g", <a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT);
</pre>
<p>
These methods throw an error if the gate does not exist, so they cannot
be used to determine whether the module has a particular gate.
For that purpose there is a <tt>hasGate()</tt> method. An example:

<pre class="cpp">
if (hasGate("optOut"))
   send(new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>(), "optOut");
</pre>
<p>
A gate can also be identified and looked up by a numeric gate ID.
You can get the ID from the gate itself (<tt>getId()</tt> method),
or from the module by gate name (<tt>findGate()</tt> method).
The <tt>gate()</tt> method also has an overloaded variant which
returns the gate from the gate ID.

<pre class="cpp">
int gateId = gate("in")-&gt;getId();  // or:
int gateId = findGate("in");
</pre>
<p>
As gate IDs are more useful with gate vectors, we'll cover them
in detail in a later section.

<p>
<h4><a name="sec:simple-modules:gate-vectors"/>4.6.1.2 Gate Vectors<a class="headerlink" href="#sec:simple-modules:gate-vectors" title="Permalink to this headline">¶</a></h4>

<p>Gate vectors possess one <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> object per element.
To access individual gates in the vector, you need to call
the <tt>gate()</tt> function with an additional <i>index</i>
parameter. The index should be between zero and <i>size</i>-1.
The size of the gate vector can be read with the <tt>gateSize()</tt>
method. The following example iterates through all elements in the
gate vector:

<pre class="cpp">
for (int i = 0; i &lt; gateSize("out"); i++) {
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = gate("out", i);
    //...
}
</pre>
<p>
A gate vector cannot have &#8220;holes&#8221; in it; that is, <tt>gate()</tt>
never returns <tt>nullptr</tt> or throws an error if the gate vector exists
and the index is within bounds.

<p>For inout gates, <tt>gateSize()</tt> may be called with or without
the <tt>"$i"</tt>/<tt>"$o"</tt> suffix, and returns the same number.

<p>The <tt>hasGate()</tt> method may be used both with and without an
index, and they mean two different things: without an index it tells
the existence of a gate vector with the given name, regardless of its
size (it returns <tt>true</tt> for an existing vector even if its size
is currently zero!); with an index it also examines whether the index
is within the bounds.

<p>
<h4><a name="sec:simple-modules:gate-ids"/>4.6.1.3 Gate IDs<a class="headerlink" href="#sec:simple-modules:gate-ids" title="Permalink to this headline">¶</a></h4>

<p>A gate can also be accessed by its ID. A very important property of gate IDs
is that they are <i>contiguous</i> within a gate vector, that is,
the ID of a gate <tt>g[k]</tt> can be calculated as the ID of <tt>g[0]</tt> plus <i>k</i>.
This allows you to efficiently access any gate in a gate vector, because
retrieving a gate by ID is more efficient than by name and index.
The index of the first gate can be obtained with <tt>gate("out",0)-&gt;getId()</tt>,
but it is better to use a dedicated method, <tt>gateBaseId()</tt>,
because it also works when the gate vector size is zero.

<p>Two further important properties of gate IDs: they are <i>stable</i>
and <i>unique</i> (within the module). By stable we mean that the ID
of a gate never changes; and by unique we not only mean that at any
given time no two gates have the same IDs, but also that IDs of deleted
gates do not get reused later, so gate IDs are unique in the lifetime
of a simulation run.

<p><ul class="note"><b>NOTE</b><br>
    OMNeT++ version earlier than 4.0 did not have these guarantees -- resizing
    a gate vector could cause its ID range to be relocated, if it
    would have overlapped with the ID range of other gate vectors.
    OMNeT++ 4.x solves the same problem by interpreting the gate ID
    as a bitfield, basically containing bits that identify the gate name,
    and other bits that hold the index. This also means that the theoretical
    upper limit for a gate size is now smaller, albeit it is still
    big enough so that it can be safely ignored for practical purposes.
</ul>

<p>The following example iterates through a gate vector, using IDs:

<pre class="cpp">
int baseId = gateBaseId("out");
int size = gateSize("out");
for (int i = 0; i &lt; size; i++) {
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = gate(baseId + i);
    //...
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:enumerating-gates"/>4.6.1.4 Enumerating All Gates<a class="headerlink" href="#sec:simple-modules:enumerating-gates" title="Permalink to this headline">¶</a></h4>

<p>If you need to go through all gates of a module, there are
two possibilities. One is invoking the <tt>getGateNames()</tt> method
that returns the names of all gates and gate vectors the module
has; then you can call <tt>isGateVector(name)</tt> to determine
whether individual names identify a scalar gate or a gate vector;
then gate vectors can be enumerated by index. Also, for inout
gates <tt>getGateNames()</tt> returns the base name without the
<tt>"$i"</tt>/<tt>"$o"</tt> suffix, so the two directions
need to be handled separately. The <tt>gateType(name)</tt> method
can be used to test whether a gate is inout, input or output
(it returns <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INOUT</tt>, <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INPUT</tt>, or
<tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT</tt>).

<p>Clearly, the above solution can be quite difficult. An alternative is to use
the <tt><a href="../api/classomnetpp_1_1cModule_1_1GateIterator.html">GateIterator</a></tt> class provided by <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>.
It goes like this:

<pre class="cpp">
for (<a href="../api/classomnetpp_1_1cModule.html">cModule</a>::<a href="../api/classomnetpp_1_1cModule_1_1GateIterator.html">GateIterator</a> i(this); !i.end(); i++) {
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = *i;
    ...
}
</pre>
<p>
Where <tt>this</tt> denotes the module whose gates are being enumerated
(it can be replaced by any <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a> *</tt> variable).

<p><ul class="note"><b>NOTE</b><br>
    In earlier OMNeT++ versions, gate IDs used to be small integers, so
    it made sense to iterate over all gates of a module by enumerating
    all IDs from zero to a maximum, skipping the holes (<tt>nullptr</tt>s).
    This is no longer the case with OMNeT++ 4.0 and later versions.
    Moreover, the <tt>gate()</tt> method now throws an error when called
    with an invalid ID, and not just returns <tt>nullptr</tt>.
</ul>

<p>
<h4><a name="sec:simple-modules:adding-and-deleting-gates"/>4.6.1.5 Adding and Deleting Gates<a class="headerlink" href="#sec:simple-modules:adding-and-deleting-gates" title="Permalink to this headline">¶</a></h4>

<p>Although rarely needed, it is possible to add and remove gates during
simulation. You can add scalar gates and gate vectors, change the size of
gate vectors, and remove scalar gates and whole gate vectors.
It is not possible to remove individual random gates from a gate vector,
to remove one half of an inout gate (e.g. <tt>"gate$o"</tt>), or to set
different gate vector sizes on the two halves of an inout gate vector.

<p>The <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> methods for adding and removing gates are
<tt>addGate(name,type,isvector=false)</tt> and <tt>deleteGate(name)</tt>.
Gate vector size can be changed by using <tt>setGateSize(name,size)</tt>.
None of these methods accept <tt>"$i"</tt> / <tt>"$o"</tt> suffix in gate names.

<p><ul class="note"><b>NOTE</b><br>
    When memory efficiency is of concern, it is useful to know that
    in OMNeT++ 4.0 and later, a gate vector will consume significantly less
    memory than the same number of individual scalar gates.
</ul>

<p>
<h4><a name="sec:simple-modules:cgate-methods"/>4.6.1.6 <a href="../api/classomnetpp_1_1cGate.html">cGate</a> Methods<a class="headerlink" href="#sec:simple-modules:cgate-methods" title="Permalink to this headline">¶</a></h4>

<p>The <tt>getName()</tt> method of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> returns the name of the
gate or gate vector without the index. If you need a string that contains the gate index
as well, <tt>getFullName()</tt> is what you want. If you also want to
include the hierarchical name of the owner module, call <tt>getFullPath()</tt>.

<p>The <tt>getType()</tt> method of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> returns the gate type,
either <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INPUT</tt> or <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT</tt>. (It cannot return
<tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INOUT</tt>, because an inout gate is represented by a pair
of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>s.)

<p>If you have a gate that represents half of an inout gate (that is,
<tt>getName()</tt> returns something like <tt>"g$i"</tt> or <tt>"g$o"</tt>), you
can split the name with the <tt>getBaseName()</tt> and
<tt>getNameSuffix()</tt> methods. <tt>getBaseName()</tt> method returns the
name without the <tt>$i</tt>/<tt>$o</tt> suffix; and <tt>getNameSuffix()</tt>
returns just the suffix (including the dollar sign). For normal gates,
<tt>getBaseName()</tt> is the same as <tt>getName()</tt>, and
<tt>getNameSuffix()</tt> returns the empty string.

<p>The <tt>isVector()</tt>, <tt>getIndex()</tt>, <tt>getVectorSize()</tt> speak
for themselves; <tt>size()</tt> is an alias to <tt>getVectorSize()</tt>. For
non-vector gates, <tt>getIndex()</tt> returns 0 and <tt>getVectorSize()</tt>
returns 1.

<p>The <tt>getId()</tt> method returns the gate ID (not to be confused
with the gate index).

<p>The <tt>getOwnerModule()</tt> method returns the module the gate object
belongs to.

<p>To illustrate these methods, we expand the gate iterator example
to print some information about each gate:

<pre class="cpp">
for (<a href="../api/classomnetpp_1_1cModule.html">cModule</a>::<a href="../api/classomnetpp_1_1cModule_1_1GateIterator.html">GateIterator</a> i(this); !i.end(); i++) {
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = *i;
    EV &lt;&lt; gate-&gt;getFullName() &lt;&lt; ": ";
    EV &lt;&lt; "id=" &lt;&lt; gate-&gt;getId() &lt;&lt; ", ";
    if (!gate-&gt;isVector())
        EV &lt;&lt; "scalar gate, ";
    else
        EV &lt;&lt; "gate " &lt;&lt; gate-&gt;getIndex()
           &lt;&lt; " in vector " &lt;&lt; gate-&gt;getName()
           &lt;&lt; " of size " &lt;&lt; gate-&gt;getVectorSize() &lt;&lt; ", ";
    EV &lt;&lt; "type:" &lt;&lt; <a href="../api/classomnetpp_1_1cGate.html">cGate</a>::getTypeName(gate-&gt;getType());
    EV &lt;&lt; "\n";
}
</pre>
<p>
There are further <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> methods to access and manipulate
the connection(s) attached to the gate; they will be covered in the
following sections.

<p>
<h3><a name="sec:simple-modules:connections"/>4.6.2 Connections<a class="headerlink" href="#sec:simple-modules:connections" title="Permalink to this headline">¶</a></h3>

<p>Simple module gates have normally one connection attached. Compound module
gates, however, need to be connected both inside and outside of the
module to be useful. A series of connections (joined with compound
module gates) is called a <i>connection path</i> or just path.
A path is directed, and it normally starts at an output gate of
a simple module, ends at an input gate of a simple module,
and passes through several compound module gates.

<p>Every <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> object contains pointers to the previous gate
and the next gate in the path (returned by the <tt>getPreviousGate()</tt>
and <tt>getNextGate()</tt> methods), so a path can be thought of as
a double-linked list.

<p>The use of the <i>previous gate</i> and <i>next gate</i> pointers
with various gate types is illustrated on figure
<a href="chap4.html#fig:ch-simple-modules:gates">below</a>.

<p>
  <center>
    <img src="simple-gates.svg">
    <center><div class="caption"><i>Figure: (a) simple module output gate, (b) compound module output gate,
             (c) simple module input gate, (d) compound module input gate</i></div></center>
    <a name="fig:ch-simple-modules:gates"></a>
  </center>

<p>
The start and end gates of the path can be found with the <tt>getPathStartGate()</tt>
and <tt>getPathEndGate()</tt> methods, which simply follow the <i>previous gate</i> and
<i>next gate</i> pointers, respectively, until they are <tt>nullptr</tt>.

<p>The <tt>isConnectedOutside()</tt> and <tt>isConnectedInside()</tt> methods
return whether a gate is connected on the outside or on the inside. They
examine either the <i>previous</i> or the <i>next</i> pointer, depending on the
gate type (input or output). For example, an output gate is <i>connected outside</i>
if the <i>next</i> pointer is non-<tt>nullptr</tt>; the same function for an input gate
checks the <i>previous</i> pointer. Again, see figure <a href="chap4.html#fig:ch-simple-modules:gates">below</a>
for an illustration.

<p>The <tt>isConnected()</tt> method is a bit different: it returns true if the gate
is <i>fully</i> connected, that is, for a compound module gate
both inside and outside, and for a simple module gate, outside.

<p>The following code prints the name of the gate a simple module gate is
connected to:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = gate("somegate");
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *otherGate = gate-&gt;getType()==<a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT ? gate-&gt;getNextGate() :
                                                    gate-&gt;getPreviousGate();
if (otherGate)
  EV &lt;&lt; "gate is connected to: " &lt;&lt; otherGate-&gt;getFullPath() &lt;&lt; endl;
else
  EV &lt;&lt; "gate not connected" &lt;&lt; endl;
</pre>
<p>

<p><h3><a name="sec:simple-modules:connections-channel"/>4.6.3 The Connection's Channel<a class="headerlink" href="#sec:simple-modules:connections-channel" title="Permalink to this headline">¶</a></h3>

<p>The channel object associated with a connection is accessible by
a pointer stored at the source gate of the connection. The pointer
is returned by the <tt>getChannel()</tt> method of the gate:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *channel = gate-&gt;getChannel();
</pre>
<p>
The result may be <tt>nullptr</tt>, that is, a connection may not have
an associated channel object.

<p>If you have a channel pointer, you can get back its source gate
with the <tt>getSourceGate()</tt> method:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = channel-&gt;getSourceGate();
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt> is just an abstract base class for channels, so
to access details of the channel you might need to cast the resulting
pointer into a specific channel class, for example <tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt>
or <tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt>.

<p>Another specific channel type is <tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt>, which basically
does nothing: it acts as if there was no channel object assigned to the
connection. OMNeT++ sometimes transparently inserts a <tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt>
into a channel-less connection, for example to hold the display string
associated with the connection.

<p>Often you are not really interested in a specific connection's channel, but
rather in the <i>transmission channel</i> (see
<a href="chap4.html#sec:simple-modules:packet-transmission">[4.7.6]</a>) of the connection path that
starts at a specific output gate. The transmission channel can be found by
following the connection path until you find a channel whose
<tt>isTransmissionChannel()</tt> method returns <tt>true</tt>, but
<tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> has a convenience method for this, named
<tt>getTransmissionChannel()</tt>. An example usage:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *txChan = gate("ppp$o")-&gt;getTransmissionChannel();
</pre>
<p>
A complementer method to <tt>getTransmissionChannel()</tt> is
<tt>getIncomingTransmissionChannel()</tt>; it is usually invoked
on input gates, and searches the connection path in reverse direction.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *incomingTxChan = gate("ppp$i")-&gt;getIncomingTransmissionChannel();
</pre>
<p>
Both methods throw an error if no transmission channel is found. If this
is not suitable, use the similar <tt>findTransmissionChannel()</tt> and
<tt>findIncomingTransmissionChannel()</tt> methods that simply return
<tt>nullptr</tt> in that case.

<p>Channels are covered in more detail in section <a href="chap4.html#sec:simple-modules:channels">[4.8]</a>.

<p>
<h2><a name="sec:simple-modules:sending-and-receiving"/>4.7 Sending and Receiving Messages<a class="headerlink" href="#sec:simple-modules:sending-and-receiving" title="Permalink to this headline">¶</a></h2>

<p>On an abstract level, an OMNeT++ simulation model is a set of
simple modules that communicate with each other via message passing.
The essence of simple modules is that they create, send, receive,
store, modify, schedule and destroy messages -- the rest of OMNeT++ exists
to facilitate this task, and collect statistics
about what was going on.

<p>Messages in OMNeT++ are instances of the <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> class or one of
its subclasses. Network packets are represented with <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>,
which is also subclassed from <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>. Message objects are
created using the C++ <tt>new</tt> operator, and destroyed using the
<tt>delete</tt> operator when they are no longer needed.

<p>Messages are described in detail in chapter <a href="chap5.html#cha:messages">[5]</a>.
At this point, all we need to know about them is that they are
referred to as <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *</tt> pointers. In the examples below,
messages will be created with <tt>new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("foo")</tt> where
<tt>"foo"</tt> is a descriptive message name, used for visualization
and debugging purposes.

<p>
<h3><a name="sec:simple-modules:self-messages"/>4.7.1 Self-Messages<a class="headerlink" href="#sec:simple-modules:self-messages" title="Permalink to this headline">¶</a></h3>

<p>Nearly all simulation models need to schedule future events in order
to implement timers, timeouts, delays, etc. Some typical examples:

<p><ul>
  <li> A source module that periodically creates and sends messages
    needs to schedule the next send after every send operation;
  <li> A server which processes jobs from a queue needs to start
    a timer every time it begins processing a job. When the timer
    expires, the finished job can be sent out, and a new job may
    start processing;
  <li> When a packet is sent by a communications protocol that employs
    retransmission, it needs to schedule a timeout so that the packet
    can be retransmitted if no acknowledge arrives within a certain
    amount of time.
</ul>

<p>In OMNeT++, you solve such tasks by letting the simple module send a message
to itself; the message would be delivered to the simple module at a later
point of time. Messages used this way are called
<i>self-messages</i><!--self-message-->, and the module class has
special methods for them that allow for implementing self-messages without
gates and connections.

<p><h4><a name="sec:simple-modules:scheduling"/>4.7.1.1 Scheduling an Event<a class="headerlink" href="#sec:simple-modules:scheduling" title="Permalink to this headline">¶</a></h4>

<p>The module can send a message to itself using the <tt>scheduleAt()</tt> function.
<tt>scheduleAt()</tt> accepts an <i>absolute</i> simulation time,
usually calculated as <tt>simTime()</tt>+<i>delta</i>:

<pre class="cpp">
scheduleAt(absoluteTime, msg);
scheduleAt(simTime()+delta, msg);
</pre>
<p>
Self-messages are delivered to the module in the same way as other
messages (via the usual receive calls or <tt>handleMessage()</tt>);
the module may call the <tt>isSelfMessage()</tt> member of any received
message to determine if it is a self-message.

<p>You can determine whether a message is currently in the FES<!--FES-->
by calling its <tt>isScheduled()</tt> member function.

<p><h4><a name="sec:simple-modules:cancelling"/>4.7.1.2 Cancelling an Event<a class="headerlink" href="#sec:simple-modules:cancelling" title="Permalink to this headline">¶</a></h4>

<p>Scheduled self-messages can be cancelled<!--self-message!cancelling-->
<!--message!cancelling--> (i.e. removed from the FES<!--FES-->).
This feature facilitates implementing timeouts.

<pre class="cpp">
cancelEvent(msg);
</pre>
<p>
The <tt>cancelEvent()</tt> function takes a pointer to the message to
be cancelled, and also returns the same pointer. After having it
cancelled, you may delete the message or reuse it in subsequent
<tt>scheduleAt()</tt> calls. <tt>cancelEvent()</tt> has no effect if
the message is not scheduled at that time.

<p>There is also a convenience method called <tt>cancelAndDelete()</tt>
implemented as <tt>if (msg!=nullptr) delete cancelEvent(msg)</tt>;
this method is primarily useful for writing destructors.

<p>The following example shows how to implement a timeout in a simple
imaginary stop-and-wait protocol. The code utilizes a <tt>timeoutEvent</tt>
module class data member that stores the pointer of the <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> used
as self-message, and compares it to the pointer of the received message
to identify whether a timeout has occurred.

<pre class="cpp">
void Protocol::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    if (msg == timeoutEvent) {
        // timeout expired, re-send packet and restart timer
        send(currentPacket-&gt;dup(), "out");
        scheduleAt(simTime() + timeout, timeoutEvent);
    }
    else if (...) {  // if acknowledgement received
        // cancel timeout, prepare to send next packet, etc.
        cancelEvent(timeoutEvent);
        ...
    }
    else {
       ...
    }
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:rescheduling"/>4.7.1.3 Re-scheduling an Event<a class="headerlink" href="#sec:simple-modules:rescheduling" title="Permalink to this headline">¶</a></h4>

<p>To reschedule an event which is currently scheduled to a different
simulation time, it first needs to be cancelled using <tt>cancelEvent()</tt>.
This is shown in the following example code:

<pre class="cpp">
if (msg-&gt;isScheduled())
    cancelEvent(msg);
scheduleAt(simTime() + delay, msg);
</pre>
<p>

<p><h3><a name="sec:simple-modules:sending-messages"/>4.7.2 Sending Messages<a class="headerlink" href="#sec:simple-modules:sending-messages" title="Permalink to this headline">¶</a></h3>

<p>Once created, a message object can be sent through an
output gate<!--output!gate--> using one of the following functions:

<pre class="cpp">
send(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, const char *gateName, int index=0);
send(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, int gateId);
send(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate);
</pre>
<p>
In the first function, the argument <tt>gateName</tt> is the name of
the gate the message has to be sent through. If this gate is
a vector gate, <tt>index</tt> determines though which particular output
gate this has to be done; otherwise, the <tt>index</tt> argument is not
needed.

<p>The second and third functions use the gate ID and the pointer to the gate
object. They are faster than the first one because they don't have to
search for the gate by name.

<p>Examples:

<pre class="cpp">
send(msg, "out");
send(msg, "outv", i); // send via a gate in a gate vector
</pre>
<p>
To send via an inout gate, remember that an inout gate is an input and an
output gate glued together, and the two halves can be identified with the
<tt>$i</tt> and <tt>$o</tt> name suffixes. Thus, the gate name needs to be
specified in the <tt>send()</tt> call with the <tt>$o</tt> suffix:

<pre class="cpp">
send(msg, "g$o");
send(msg, "g$o", i); // if "g[]" is a gate vector
</pre>
<p>

<p><h3><a name="sec:simple-modules:broadcasts-and-retransmissions"/>4.7.3 Broadcasts and Retransmissions<a class="headerlink" href="#sec:simple-modules:broadcasts-and-retransmissions" title="Permalink to this headline">¶</a></h3>

<p>When implementing broadcasts or retransmissions, two frequently
occurring tasks in protocol simulation, you might feel tempted
to use the same message in multiple <tt>send()</tt> operations.
Do not do it -- you cannot send the same message object multiple times.
Instead, duplicate the message object.

<p>Why? A message is like a real-world object -- it cannot be at two places
at the same time. Once sent out, the message no longer belongs
to the module: it is taken over by the simulation kernel, and will
eventually be delivered to the destination module. The sender module should
not even refer to its pointer any more. Once the message arrives in the
destination module, that module will have full authority over it -- it can
send it on, destroy it immediately, or store it for further handling. The
same applies to messages that have been scheduled -- they belong to the
simulation kernel until they are delivered back to the module.

<p>To enforce the rules above, all message sending functions check that the
module actually owns the message it is about to send. If the message is in
another module, in a queue, currently scheduled, etc., a runtime error
will be generated: <i>not owner of message</i>.
  <br><ul><font size=-1>[The feature does not increase runtime overhead significantly, because
  it uses the object ownership<!--ownership--> management (described in
  Section <a href="chap7.html#sec:sim-lib:ownership-management">[7.13]</a>);
  it merely checks that the owner of the message is the module that
  wants to send it.]</font></ul>

<p>
<h4><a name="sec:simple-modules:broadcasting-messages"/>4.7.3.1 Broadcasting Messages<a class="headerlink" href="#sec:simple-modules:broadcasting-messages" title="Permalink to this headline">¶</a></h4>

<p>In your model, you may need to broadcast a message to several destinations.
Broadcast can be implemented in a simple module by sending out copies
of the same message, for example on every gate of a gate vector.
As described above, you cannot use the same message pointer for
in all <tt>send()</tt> calls -- what you have to do instead is
create copies (duplicates) of the message object and send them.

<p>Example:

<pre class="cpp">
for (int i = 0; i &lt; n; i++)
{
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *copy = msg-&gt;dup();
    send(copy, "out", i);
}
delete msg;
</pre>
<p>
You might have noticed that copying the message for the last gate is
redundant: we can just send out the original message there.
Also, we can utilize gate IDs to avoid looking up the gate by name
for each send operation. We can exploit the fact that the ID of gate
<i>k</i> in a gate vector can be produced as <i>baseID + k</i>.
The optimized version of the code looks like this:

<pre class="cpp">
int outGateBaseId = gateBaseId("out");
for (int i = 0; i &lt; n; i++)
    send(i==n-1 ? msg : msg-&gt;dup(), outGateBaseId+i);
</pre>
<p>

<p><h4><a name="sec:simple-modules:retransmissions"/>4.7.3.2 Retransmissions<a class="headerlink" href="#sec:simple-modules:retransmissions" title="Permalink to this headline">¶</a></h4>

<p>Many communication protocols involve retransmissions of packets (frames).
When implementing retransmissions, you cannot just hold a pointer
to the same message object and send it again and again -- you'd get
the <i>not owner of message</i> error on the first resend.

<p>Instead, for (re)transmission, you should create and
send copies of the message, and retain the original.
When you are sure there will not be any more retransmission,
you can delete the original message.

<p>Creating and sending a copy:

<pre class="cpp">
// (re)transmit packet:
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *copy = packet-&gt;dup();
send(copy, "out");
</pre>
<p>
and finally (when no more retransmissions will occur):

<pre class="cpp">
delete packet;
</pre>
<p>

<p><h3><a name="sec:simple-modules:delayed-sending"/>4.7.4 Delayed Sending<a class="headerlink" href="#sec:simple-modules:delayed-sending" title="Permalink to this headline">¶</a></h3>

<p>Sometimes it is necessary for module to hold a message for some time interval,
and then send it. This can be achieved with self-messages, but there is a
more straightforward method: delayed sending<!--delayed sending-->. The
following methods are provided for delayed sending:

<pre class="cpp">
sendDelayed(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, double delay, const char *gateName, int index);
sendDelayed(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, double delay, int gateId);
sendDelayed(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, double delay, <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate);
</pre>
<p>
The arguments are the same as for <tt>send()</tt>, except for the extra
<i>delay</i> parameter. The delay value must be non-negative.
The effect of the function is similar to as if the module
had kept the message for the delay interval and sent it afterwards;
even the <i>sending time</i> timestamp of the message will be set to
the current simulation time plus <i>delay</i>.

<p>A example call:

<pre class="cpp">
sendDelayed(msg, 0.005, "out");
</pre>
<p>
The <tt>sendDelayed()</tt> function does not internally perform a
<tt>scheduleAt()</tt> followed by a <tt>send()</tt>, but rather it computes
everything about the message sending up front, including the arrival time
and the target module. This has two consequences. First,
<tt>sendDelayed()</tt> is more efficient than a <tt>scheduleAt()</tt>
followed by a <tt>send()</tt> because it eliminates one event. The second, less
pleasant consequence is that changes in the connection path during the
delay will <i>not</i> be taken into account (because everything is
calculated in advance, before the changes take place).

<p><ul class="note"><b>NOTE</b><br>
  The fact that <tt>sendDelayed()</tt> computes the message arrival
  information up front does not make a difference if the model is static,
  but may lead to surprising results if the model changes in time.
  For example, if a connection in the path gets deleted, disabled, or
  reconnected to another module during the delay period, the message
  will still be delivered to the original module as if nothing happened.

<p>  Therefore, despite its performance advantage, you should think twice
  before using <tt>sendDelayed()</tt> in a simulation model. It may have
  its place in a one-shot simulation model that you know is static,
  but it certainly should be avoided in reusable modules that need to
  work correctly in a wide variety of simulation models.
</ul>

<p>
<h3><a name="sec:simple-modules:direct-sending"/>4.7.5 Direct Message Sending<a class="headerlink" href="#sec:simple-modules:direct-sending" title="Permalink to this headline">¶</a></h3>

<p>At times it is covenient to be able to send a message directly to an input
gate of another module. The <tt>sendDirect()</tt> function is provided for
this purpose.

<p>This function has several flavors. The first set of <tt>sendDirect()</tt>
functions accept a message and a target gate; the latter can be specified
in various forms:

<pre class="cpp">
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, int gateId)
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, const char *gateName, int index=-1)
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate)
</pre>
<p>
An example for direct sending:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *targetModule = getParentModule()-&gt;getSubmodule("node2");
sendDirect(new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("msg"), targetModule, "in");
</pre>
<p>
At the target module, there is no difference between messages received
directly and those received over connections.

<p>The target gate must be an unconnected gate; in other words,
modules must have dedicated gates to be able to receive messages
sent via <tt>sendDirect()</tt>. You cannot have a gate which receives
messages via both connections and <tt>sendDirect()</tt>.

<p>It is recommended to tag gates dedicated for receiving messages via
<tt>sendDirect()</tt> with the <tt>@directIn</tt> property in the module's NED
declaration. This will cause OMNeT++ not to complain that the gate is not
connected in the network or compound module where the module is used.

<p>An example:

<pre class="ned">
simple Radio {
    gates:
        input radioIn @directIn; // for receiving air frames
}
</pre>
<p>
The target module is usually a simple module, but it can also be a compound
module. The message will follow the connections that start at the target
gate, and will be delivered to the module at the end of the path -- just as
with normal connections. The path must end in a simple module.

<p>It is even permitted to send to an output gate, which will also cause the
message to follow the connections starting at that gate.
This can be useful, for example, when several submodules are sending
to a single output gate of their parent module.

<p>A second set of <tt>sendDirect()</tt> methods accept a propagation
delay and a transmission duration as parameters as well:

<pre class="cpp">
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, int gateId)
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, const char *gateName, int index=-1)
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate)
</pre>
<p>
The transmission duration parameter is important when the message is also
a packet (instance of <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>). For messages that are not packets
(not subclassed from <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>), the duration parameter
is ignored.

<p>If the message is a packet, the duration will be written into the packet,
and can be read by the receiver with the <tt>getDuration()</tt> method of
the packet.

<p>The receiver module can choose whether it wants the simulation kernel
to deliver the packet object to it at the start or at the end of the
reception. The default is the latter; the module can change it by calling
<tt>setDeliverOnReceptionStart()</tt> on the final input gate, that is, on
<tt>targetGate-&gt;getPathEndGate()</tt>.

<p>
<h3><a name="sec:simple-modules:packet-transmission"/>4.7.6 Packet Transmissions<a class="headerlink" href="#sec:simple-modules:packet-transmission" title="Permalink to this headline">¶</a></h3>

<p>When a message is sent out on a gate, it usually travels through
a series of connections until it arrives at the destination module.
We call this series of connections a <i>connection path</i>.

<p>Several connections in the path may have an associated channel,
but there can be only one channel per path that models nonzero
transmission duration. This restriction is enforced by the simulation
kernel. This channel is called the <i>transmission channel</i>.
  <br><ul><font size=-1>[Moreover, if <tt>sendDirect()</tt> with a nonzero duration
  was used to send the packet to the start gate of the path,
  then the path cannot have a transmission channel at all.
  The point is that the a transission duration must be unambiguous.]</font></ul>

<p><ul class="note"><b>NOTE</b><br>
  In practice, this means that there can be only one <tt>ned.DatarateChannel</tt>
  in the path. Note that unnamed channels with a <tt>datarate</tt> parameter
  also map to <tt>ned.DatarateChannel</tt>.
</ul>

<p><h4><a name="sec:simple-modules:transmitting-a-packet"/>4.7.6.1 Transmitting a Packet<a class="headerlink" href="#sec:simple-modules:transmitting-a-packet" title="Permalink to this headline">¶</a></h4>

<p>Packets may only be sent when the transmission channel is idle.
This means that after each transmission, the sender module needs
to wait until the channel has finished transmitting before it can
send another packet.

<p>You can get a pointer to the transmission channel by calling the
<tt>getTransmissionChannel()</tt> method on the output gate.
The channel's <tt>isBusy()</tt> and <tt>getTransmissionFinishTime()</tt>
methods can tell you whether a channel is currently transmitting,
and when the transmission is going to finish. (When the latter is
less or equal the current simulation time, the channel is free.)
If the channel is currently busy, sending needs to be postponed:
the packet can be stored in a queue, and a timer (self-message) can be
scheduled for the time when the channel becomes empty.

<p>A code example to illustrate the above process:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *pkt = ...; // packet to be transmitted
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *txChannel = gate("out")-&gt;getTransmissionChannel();
simtime_t txFinishTime = txChannel-&gt;getTransmissionFinishTime();
if (txFinishTime &lt;= simTime())
{
    // channel free; send out packet immediately
    send(pkt, "out");
}
else
{
    // store packet and schedule timer; when the timer expires,
    // the packet should be removed from the queue and sent out
    txQueue.insert(pkt);
    scheduleAt(txFinishTime, endTxMsg);
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  If there is a channel with a propagation delay in
  the path before the transmission channel, the delay should be manually
  substracted from the value returned by <tt>getTransmissionFinishTime()</tt>!
  The same applies to <tt>isBusy()</tt>: it tells whether the channel is
  currently busy, and not whether it will be busy when a packet that you send
  gets there. It is therefore advisable that you never use propagation delays
  in front of a transmission channel in a path.
</ul>

<p>The <tt>getTransmissionChannel()</tt> method searches the connection path each
time it is called. If performance is important, it is a good idea to obtain
the transmission channel pointer once, and then cache it. When the network topology
changes, the cached channel pointer needs to be updated; section
<a href="chap4.html#sec:simple-modules:model-change">[4.14.3]</a> describes the mechanism that can
be used to get notifications about topology changes.

<p><h4><a name="sec:simple-modules:receiving-a-packet"/>4.7.6.2 Receiving a Packet<a class="headerlink" href="#sec:simple-modules:receiving-a-packet" title="Permalink to this headline">¶</a></h4>

<p>As a result of error modeling in the channel, the packet may arrive
with the <i>bit error</i> flag set (<tt>hasBitError() method</tt>.
It is the receiver module's responsibility to examine this flag
and take appropriate action (i.e. discard the packet).

<p>Normally the packet object gets delivered to the destination module
at the simulation time that corresponds to finishing the reception
of the message (ie. the arrival of its last bit). However, the receiver
module may change this by &#8220;reprogramming&#8221; the receiver gate with
the <tt>setDeliverOnReceptionStart()</tt> method:

<pre class="cpp">
gate("in")-&gt;setDeliverOnReceptionStart(true);
</pre>
<p>
This method may only be called on simple module input gates, and it
instructs the simulation kernel to deliver packets arriving through
that gate at the simulation time that corresponds to the
beginning of the reception process.
<tt>getDeliverOnReceptionStart()</tt> only needs to be called once,
so it is usually done in the <tt>initialize()</tt> method of the module.

<p>
  <center>
    <img src="transmission.svg">
    <center><div class="caption"><i>Figure: Packet transmission</i></div></center>
    <a name="fig:ch-simple-modules:transmission"></a>
  </center>

<p>
When a packet is delivered to the module, the packet's
<tt>isReceptionStart()</tt> method can be called to determine
whether it corresponds to the start or end of the reception
process (it should be the same as the <tt>getDeliverOnReceptionStart()</tt>
flag of the input gate), and <tt>getDuration()</tt> returns the transmission
duration.

<p>The following example code prints the start and end times of a packet reception:

<pre class="cpp">
simtime_t startTime, endTime;
if (pkt-&gt;isReceptionStart())
{
    // gate was reprogrammed with setDeliverOnReceptionStart(true)
    startTime = pkt-&gt;getArrivalTime(); // or: simTime();
    endTime = startTime + pkt-&gt;getDuration();
}
else
{
    // default case
    endTime = pkt-&gt;getArrivalTime(); // or: simTime();
    startTime = endTime - pkt-&gt;getDuration();
}
EV &lt;&lt; "interval: " &lt;&lt; startTime &lt;&lt; ".." &lt;&lt; endTime &lt;&lt; "\n";
</pre>
<p>
Note that this works with wireless connections (<tt>sendDirect()</tt>)
as well; there, the duration is an argument to the <tt>sendDirect()</tt>
call.

<p><h4><a name="sec:simple-modules:aborting-transmissions"/>4.7.6.3 Aborting Transmissions<a class="headerlink" href="#sec:simple-modules:aborting-transmissions" title="Permalink to this headline">¶</a></h4>

<p>Certain protocols, for example Ethernet require the ability to abort
a transmission before it completes. The support OMNeT++ provides
for this task is the <tt>forceTransmissionFinishTime()</tt> channel method.
This method forcibly overwrites the <i>transmissionFinishTime</i>
member of the channel with the given value, allowing the sender to transmit
another packet without raising the <i>&#8220;channel is currently busy&#8221;</i>
error. The receiving party needs to be notified about the aborted transmission
by some external means, for example by sending another packet or an
out-of-band message.

<p><h4><a name="sec:simple-modules:implementation-of-message-sending"/>4.7.6.4 Implementation of Message Sending<a class="headerlink" href="#sec:simple-modules:implementation-of-message-sending" title="Permalink to this headline">¶</a></h4>

<p>Message sending is implemented like this: the arrival time<!--arrival time-->
and the bit error<!--bit error--> flag of a message are calculated right inside
the <tt>send()</tt> call, then the message is inserted into the FES<!--FES-->
with the calculated arrival time. The message does <i>not</i> get scheduled
individually for each link. This implementation was chosen because of its
run-time efficiency.

<p><ul class="note"><b>NOTE</b><br>
   The consequence of this implementation is that any change in the
   channel's parameters (delay, data rate, bit error rate, etc.) will only affect
   messages <i>sent</i> after the change. Messages already underway will not
   be influenced by the change.

<p>   This is not a huge problem in practice, but if it is important to model
   channels with changing parameters, the solution is to insert simple modules
   into the path to ensure strict scheduling.
</ul>

<p>The code which inserts the message into the FES is the <tt>arrived()</tt>
method of the recipient module. By overriding this method it is possible 
to perform custom processing at the recipient module immediately, still 
from within the <tt>send()</tt> call. Use only if you know what you are doing!

<p>
<h3><a name="sec:simple-modules:receiving-with-activity"/>4.7.7 Receiving Messages with activity()<a class="headerlink" href="#sec:simple-modules:receiving-with-activity" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:receive"/>4.7.7.1 Receiving Messages<a class="headerlink" href="#sec:simple-modules:receive" title="Permalink to this headline">¶</a></h4>

<p><tt>activity()</tt>-based modules receive messages with the <tt>receive()</tt>
method of <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>. <tt>receive()</tt> cannot be used with
<tt>handleMessage()</tt>-based modules.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg = receive();
</pre>
<p>
The <tt>receive()</tt> function accepts an optional <i>timeout</i>
parameter<!--receive!timeout-->. (This is a <i>delta</i>, not an
absolute simulation time.) If no message arrives within the timeout
period, the function returns <tt>nullptr</tt>.
    <br><ul><font size=-1>[Putaside-queue and the functions <tt>receiveOn()</tt>,
    <tt>receiveNew()</tt>, and <tt>receiveNewOn()</tt> were deprecated
    in OMNeT++ 2.3 and removed in OMNeT++ 3.0.]</font></ul>

<pre class="cpp">
simtime_t timeout = 3.0;
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg = receive(timeout);

if (msg==nullptr)
{
    ...   // handle timeout
}
else
{
    ...  // process message
}
</pre>
<p>
<h4><a name="sec:simple-modules:wait"/>4.7.7.2 The wait() Function<a class="headerlink" href="#sec:simple-modules:wait" title="Permalink to this headline">¶</a></h4>

<p>The <tt>wait()</tt> function suspends the execution of the module for a
given amount of simulation time (a <i>delta</i>). <tt>wait()</tt> cannot
be used with <tt>handleMessage()</tt>-based modules.

<pre class="cpp">
wait(delay);
</pre>
<p>
In other simulation software, <tt>wait()</tt> is often called <i>hold</i>.
Internally, the <tt>wait()</tt> function is implemented by a
<tt>scheduleAt()</tt> followed by a <tt>receive()</tt>.
The <tt>wait()</tt> function is very convenient in modules that do not need
to be prepared for arriving messages, for example message generators.
An example:

<pre class="cpp">
for (;;)
{
    // wait for some, potentially random, amount of time, specified
    // in the interarrivalTime volatile module parameter
    wait(par("interarrivalTime").doubleValue());

    // generate and send message
    ...
}
</pre>
<p>
It is a runtime error if a message arrives during the wait interval.
If you expect messages to arrive during the wait period, you can
use the <tt>waitAndEnqueue()</tt> function. It takes a pointer to a queue object
(of class <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>, described in chapter <a href="chap7.html#cha:sim-lib">[7]</a>)
in addition to the wait interval. Messages that arrive during the
wait interval are accumulated in the queue, and they can be
processed after the <tt>waitAndEnqueue()</tt> call returns.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a> queue("queue");
...
waitAndEnqueue(waitTime, &queue);
if (!queue.empty())
{
    // process messages arrived during wait interval
    ...
}
</pre>
<p>

<p><h2><a name="sec:simple-modules:channels"/>4.8 Channels<a class="headerlink" href="#sec:simple-modules:channels" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:channels-overview"/>4.8.1 Overview<a class="headerlink" href="#sec:simple-modules:channels-overview" title="Permalink to this headline">¶</a></h3>

<p>Channels encapsulate parameters and behavior associated with connections.
Channel types are like simple modules, in the sense that they are declared
in NED, and there are C++ implementation classes behind them. Section
<a href="chap3.html#sec:ned-lang:channels">[3.5]</a> describes NED language support for channels,
and explains how to associate C++ classes with channel types declared in
NED.

<p>C++ channel classes must subclass from the abstract base class
<tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>. However, when creating a new channel class, it may be
more practical to extend one of the existing C++ channel classes behind the
three predefined NED channel types:

<p><ul>
  <li> <tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt> implements the functionality of <tt>ned.IdealChannel</tt>
  <li> <tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> implements the functionality of <tt>ned.DelayChannel</tt>
  <li> <tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt> implements the functionality of <tt>ned.DatarateChannel</tt>
</ul>

<p>Channel classes need to be registered with the <tt>Define_Channel()</tt> macro,
just like simple module classes need <tt>Define_Module()</tt>.

<p>The channel base class <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt> inherits from <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>,
so channels participate in the initialization and finalization protocol
(<tt>initialize()</tt> and <tt>finish()</tt>) described in
<a href="chap4.html#sec:simple-modules:initialize-and-finish">[4.3.3]</a>.

<p>The parent module of a channel (as returned by the
<tt>getParentModule()</tt>) is the module that contains
the connection. If a connection connects two modules that are children of
the same compound module, the channel's parent is the compound module. If
the connection connects a compound module to one of its submodules, the
channel's parent is also the compound module.

<p>
<h3><a name="sec:simple-modules:channel-api"/>4.8.2 The Channel API<a class="headerlink" href="#sec:simple-modules:channel-api" title="Permalink to this headline">¶</a></h3>

<p>When subclassing <tt>Channel</tt>, the following pure virtual member functions
need to be overridden:

<p><ul>
  <li> <tt>bool isTransmissionChannel() const</tt>
  <li> <tt>simtime_t getTransmissionFinishTime() const</tt>
  <li> <tt>void processMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t t, result_t&amp; result)</tt>
</ul>

<p>The first two functions are usually one-liners; the channel behavior is
encapsulated in the third function, <tt>processMessage()</tt>.

<p><h4><a name="sec:simple-modules:transmission-channels"/>4.8.2.1 Transmission Channels<a class="headerlink" href="#sec:simple-modules:transmission-channels" title="Permalink to this headline">¶</a></h4>

<p>The first function, <tt>isTransmissionChannel()</tt>, determines whether
the channel is a <i>transmission channel</i>, i.e. one that models
transmission duration. A transmission channel sets the duration field of
packets sent through it (see the <tt>setDuration()</tt> field of
<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>).

<p>The <tt>getTransmissionFinishTime()</tt> function is only used with
transmission channels, and it should return the simulation time the sender
will finish (or has finished) transmitting. This method is called by
modules that send on a transmission channel to find out when the channel
becomes available. The channel's <tt>isBusy()</tt> method is implemented
simply as <tt>return getTransmissionFinishTime() &lt; simTime()</tt>. For
non-transmission channels, the <tt>getTransmissionFinishTime()</tt> return
value may be any simulation time which is less than or equal to the current
simulation time.

<p><h4><a name="sec:simple-modules:channel-processmessage"/>4.8.2.2 The processMessage() Function<a class="headerlink" href="#sec:simple-modules:channel-processmessage" title="Permalink to this headline">¶</a></h4>

<p>The third function, <tt>processMessage()</tt> encapsulates the channel's
functionality. However, before going into the details of this function
we need to understand how OMNeT++ handles message sending on connections.

<p>Inside the <tt>send()</tt> call, OMNeT++ follows the
connection path denoted by the <tt>getNextGate()</tt> functions of gates,
until it reaches the target module. At each &#8220;hop&#8221;, the corresponding
connection's channel (if the connection has one) gets a chance to add to
the message's arrival time (<i>propagation time modeling</i>), calculate a
<i>transmission duration</i>, and to modify the message object in various
ways, such as set the bit error flag in it (<i>bit error modeling</i>).
After processing all hops that way, OMNeT++ inserts the message object
into the Future Events Set (FES<!--FES-->, see section
<a href="chap4.html#sec:simple-modules:event-loop">[4.1.2]</a>), and the <tt>send()</tt> call returns.
Then OMNeT++ continues to process events in increasing timestamp order.
The message will be delivered to the target module's <tt>handleMessage()</tt>
(or <tt>receive()</tt>) function when it gets to the front of the FES.

<p>A few more details: a channel may instruct OMNeT++ to delete the message
instead of inserting it into the FES; this can be useful to model
disabled channels, or to model that the message has been lost altogether.
The <tt>getDeliverOnReceptionStart()</tt> flag of the final gate in the path
will determine whether the transmission duration will be added to the
arrival time or not. Packet transmissions have been described in section
<a href="chap4.html#sec:simple-modules:packet-transmission">[4.7.6]</a>.

<p>Now, back to the <tt>processMessage()</tt> method.

<p>The method gets called as part of the above process, when the message
is processed at the given hop. The method's arguments are the message
object, the simulation time the beginning of the message will reach
the channel (i.e. the sum of all previous propagation delays),
and a struct in which the method can return the results.

<p>The <tt>result_t</tt> struct is an inner type of <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>,
and looks like this:

<pre class="cpp">
struct result_t {
    simtime_t delay;     // propagation delay
    simtime_t duration;  // transmission duration
    bool discard;        // whether the channel has lost the message
};
</pre>
<p>
It also has a constructor that initializes all fields to zero; it is left
out for brevity.

<p>The method should model the transmission of the given message starting at
the given <i>t</i> time, and store the results (propagation delay,
transmission duration, deletion flag) in the result object. Only the
relevant fields in the result object need to be changed, others can be left
untouched.

<p>Transmission duration and bit error modeling only applies to packets (i.e.
to instances of <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>, where <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>'s
<tt>isPacket()</tt> returns true); it should be skipped for non-packet
messages. <tt>processMessage()</tt> does not need to call the <tt>setDuration()</tt>
method on the packet; this is done by the simulation kernel. However,
it should call <tt>setBitError(true)</tt> on the packet
if error modeling results in bit errors.

<p>If the method sets the <tt>discard</tt> flag in the result object, that
means that the message object will be deleted by OMNeT++; this facility
can be used to model that the message gets lost in the channel.

<p>The <tt>processMessage()</tt> method does not need to throw error on overlapping
transmissions, or if the packet's duration field is already set; these
checks are done by the simulation kernel before <tt>processMessage()</tt> is called.



<p><h3><a name="sec:simple-modules:channel-examples"/>4.8.3 Channel Examples<a class="headerlink" href="#sec:simple-modules:channel-examples" title="Permalink to this headline">¶</a></h3>

<p>To illustrate coding channel behavior, we look at how the built-in channel
types are implemented.

<p><tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt> lets through messages and packets without
any delay or change. Its <tt>isTransmissionChannel()</tt> method returns
<tt>false</tt>, <tt>getTransmissionFinishTime()</tt> returns <i>0s</i>, and the
body of its <tt>processMessage()</tt> method is empty:

<pre class="cpp">
void <a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a>::processMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
}
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> implements propagation delay, and it can be
disabled; in its disabled state, messages sent though it will be discarded.
This class still models zero transmission duration, so its
<tt>isTransmissionChannel()</tt> and <tt>getTransmissionFinishTime()</tt>
methods still return <tt>false</tt> and <i>0s</i>. The <tt>processMessage()</tt> method
sets the appropriate fields in the <tt>result_t</tt> struct:

<pre class="cpp">
void <a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a>::processMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
    // if channel is disabled, signal that message should be deleted
    result.discard = isDisabled;

    // propagation delay modeling
    result.delay = delay;
}
</pre>
<p>
The <tt>handleParameterChange()</tt> method is also redefined, so that
the channel can update its internal <tt>delay</tt> and <tt>isDisabled</tt>
data members if the corresponding channel parameters change during simulation.
<br><ul><font size=-1>[This code is a little simplified; the actual code uses a bit
in a bitfield to store the value of <tt>isDisabled</tt>.]</font></ul>

<p><tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt> is different. It performs model packet duration
(duration is calculated from the data rate and the length of the packet),
so <tt>isTransmissionChannel()</tt> returns <tt>true</tt>.
<tt>getTransmissionFinishTime()</tt> returns the value of a <tt>txfinishtime</tt>
data member, which gets updated after every packet.

<pre class="cpp">
simtime_t <a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a>::getTransmissionFinishTime() const
{
    return txfinishtime;
}
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt>'s <tt>processMessage()</tt> method makes use of
the <tt>isDisabled</tt>, <tt>datarate</tt>, <tt>ber</tt> and <tt>per</tt> data
members, which are also kept up to date with the help of
<tt>handleParameterChange()</tt>.

<pre class="cpp">
void <a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a>::processMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
    // if channel is disabled, signal that message should be deleted
    if (isDisabled) {
        result.discard = true;
        return;
    }

    // datarate modeling
    if (datarate!=0 && msg-&gt;isPacket()) {
        simtime_t duration = ((<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *)msg)-&gt;getBitLength() / datarate;
        result.duration = duration;
        txfinishtime = t + duration;
    }
    else {
        txfinishtime = t;
    }

    // propagation delay modeling
    result.delay = delay;

    // bit error modeling
    if ((ber!=0 || per!=0) && msg-&gt;isPacket()) {
        <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *pkt = (<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *)msg;
        if (ber!=0 && dblrand() &lt; 1.0 - pow(1.0-ber, (double)pkt-&gt;getBitLength())
            pkt-&gt;setBitError(true);
        if (per!=0 && dblrand() &lt; per)
            pkt-&gt;setBitError(true);
    }
}
</pre>
<p>

<p>
<h2><a name="sec:simple-modules:stopping"/>4.9 Stopping the Simulation<a class="headerlink" href="#sec:simple-modules:stopping" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:endsimulation"/>4.9.1 Normal Termination<a class="headerlink" href="#sec:simple-modules:endsimulation" title="Permalink to this headline">¶</a></h3>

<p>You can finish the simulation with the <tt>endSimulation()</tt> function:

<pre class="cpp">
endSimulation();
</pre>
<p>
<tt>endSimulation()</tt> is rarely needed in practice because you
can specify simulation time and CPU time limits<!--simulation time limits-->
in the ini file (see later).

<p><h3><a name="sec:simple-modules:raising-errors"/>4.9.2 Raising Errors<a class="headerlink" href="#sec:simple-modules:raising-errors" title="Permalink to this headline">¶</a></h3>

<p>When the simulation encounters an error condition, it can throw a
<tt><a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a></tt> exception to terminate the simulation with an error
message. (Under Cmdenv, the exception also causes a nonzero program exit
code). The <tt><a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a></tt> class has a constructor with a
<tt>printf()</tt>-like argument list. An example:

<pre class="cpp">
if (windowSize &lt;= 0)
    throw <a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a>("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>
Do not include newline (<tt>\n</tt>), period or exclamation mark
in the error text; it will be added by OMNeT++.

<p>The same effect can be achieved by calling the <tt>error()</tt> method of
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>:

<pre class="cpp">
if (windowSize &lt;= 0)
    error("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>
Of course, the <tt>error()</tt> method can only be used when a module pointer
is available.

<p>

<p><h2><a name="sec:simple-modules:fsm"/>4.10 Finite State Machines<a class="headerlink" href="#sec:simple-modules:fsm" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:fsm-overview"/>4.10.1 Overview<a class="headerlink" href="#sec:simple-modules:fsm-overview" title="Permalink to this headline">¶</a></h3>

<p>Finite State Machines<!--finite state machine--> (FSMs)<!--FSM-->
can make life with <tt>handleMessage()</tt> easier. OMNeT++ provides a
class and a set of macros to build FSMs.

<p>The key points are:
<ul>
<li> There are two kinds of states:
    <i>transient</i><!--transient states--> and
    <i>steady</i><!--steady states-->. On each event (that is, at
    each call to <tt>handleMessage()</tt>), the FSM transitions out of
    the current (<i>steady</i>) state, undergoes a series of state
    changes (runs through a number of <i>transient</i> states), and
    finally arrives at another <i>steady</i> state. Thus between two
    events, the system is always in one of the steady states.
    Transient states are therefore not really a must -- they exist
    only to group actions to be taken during a transition in a
    convenient way.
<li> You can assign program code to handle entering and leaving a state
    (known as entry/exit code)<!--entry code--><!--exit code-->.
    Staying in the same state is handled as leaving and re-entering
    the state.
<li> Entry code should not modify the state (this is verified by
    OMNeT++).  State changes (transitions) must be put into the exit
    code.
</ul>

<p>OMNeT++'s FSMs <i>can</i> be nested<!--FSM!nested-->. This means
that any state (or rather, its entry or exit code) may contain a
further full-fledged <tt>FSM_Switch()</tt> (see below). This allows you
to introduce sub-states and thereby bring some structure into the
state space if it becomes too large.

<p>
<h4><a name="sec:simple-modules:fsm-api"/>4.10.1.1 The FSM API<a class="headerlink" href="#sec:simple-modules:fsm-api" title="Permalink to this headline">¶</a></h4>

<p>FSM state is stored in an object of type <tt><a href="../api/classomnetpp_1_1cFSM.html">cFSM</a></tt>. The possible states
are defined by an enum; the enum is also a place to define which
state is transient and which is steady. In the following example, SLEEP
and ACTIVE are steady states and SEND is transient (the numbers
in parentheses must be unique within the state type and they are used
for constructing the numeric IDs for the states):

<pre class="cpp">
enum {
  INIT = 0,
  SLEEP = FSM_Steady(1),
  ACTIVE = FSM_Steady(2),
  SEND = FSM_Transient(1),
};
</pre>
<p>
The actual FSM is embedded in a switch-like statement, <tt>FSM_Switch()</tt>,
with cases for entering and leaving each state:

<pre class="cpp">
FSM_Switch(fsm)
{
  case FSM_Exit(state1):
    //...
    break;
  case FSM_Enter(state1):
    //...
    break;
  case FSM_Exit(state2):
    //...
    break;
  case FSM_Enter(state2):
    //...
    break;
  //...
};
</pre>
<p>

<p>State transitions<!--state transition--> are done via calls to
<tt>FSM_Goto()</tt>, which simply stores the new state in the
<tt><a href="../api/classomnetpp_1_1cFSM.html">cFSM</a></tt> object:

<pre class="cpp">
FSM_Goto(fsm, newState);
</pre>
<p>
The FSM starts from the state with the numeric code 0; this state
is conventionally named INIT.

<p>
<h4><a name="sec:simple-modules:debugging-fsms"/>4.10.1.2 Debugging FSMs<a class="headerlink" href="#sec:simple-modules:debugging-fsms" title="Permalink to this headline">¶</a></h4>

<p>FSMs can log their state transitions, with the output looking like this:

<pre class="filelisting">
...
FSM GenState: leaving state SLEEP
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SEND
FSM GenState: leaving state SEND
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SLEEP
...
</pre>
<p>
To enable the above output, define <tt>FSM_DEBUG</tt> before including <tt>omnetpp.h</tt>.

<pre class="cpp">
#define FSM_DEBUG    // enables debug output from FSMs
#include &lt;omnetpp.h&gt;
</pre>
<p>
FSMs perform their logging via the <tt>FSM_Print()</tt> macro, defined as
something like this:

<pre class="cpp">
#define FSM_Print(fsm,exiting)
  (EV &lt;&lt; "FSM " &lt;&lt; (fsm).getName()
      &lt;&lt; ((exiting) ? ": leaving state " : ": entering state ")
      &lt;&lt; (fsm).getStateName() &lt;&lt; endl)
</pre>
<p>
The log output format can be changed by undefining <tt>FSM_Print()</tt> after the
inclusion of <tt>omnetpp.ini</tt>, and providing a new definition.

<p>
<h4><a name="sec:simple-modules:fsm-implementation"/>4.10.1.3 Implementation<a class="headerlink" href="#sec:simple-modules:fsm-implementation" title="Permalink to this headline">¶</a></h4>

<p><tt>FSM_Switch()</tt> is a macro. It expands to a <tt>switch</tt>
statement embedded in a <tt>for()</tt> loop which repeats until the
FSM reaches a steady state.

<p>Infinite loops are avoided by counting state transitions: if
an FSM goes through 64 transitions without reaching a steady
state, the simulation will terminate with an error message.

<p>
<h4><a name="sec:simple-modules:fsm-example"/>4.10.1.4 An Example<a class="headerlink" href="#sec:simple-modules:fsm-example" title="Permalink to this headline">¶</a></h4>

<p>Let us write another bursty packet generator. It will have two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the Fifo2 sample
simulation.

<p>
<pre class="cpp">
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;
using namespace omnetpp;

class BurstyGenerator : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    // parameters
    double sleepTimeMean;
    double burstTimeMean;
    double sendIATime;
    <a href="../api/classomnetpp_1_1cPar.html">cPar</a> *msgLength;

    // FSM and its states
    <a href="../api/classomnetpp_1_1cFSM.html">cFSM</a> fsm;
    enum {
      INIT = 0,
      SLEEP = FSM_Steady(1),
      ACTIVE = FSM_Steady(2),
      SEND = FSM_Transient(1),
    };

    // variables used
    int i;
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *startStopBurst;
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *sendMessage;

    // the virtual functions
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    fsm.setName("fsm");
    sleepTimeMean = par("sleepTimeMean");
    burstTimeMean = par("burstTimeMean");
    sendIATime = par("sendIATime");
    msgLength = &par("msgLength");
    i = 0;
    WATCH(i); // always put watches in initialize()
    startStopBurst = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("startStopBurst");
    sendMessage = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("sendMessage");
    scheduleAt(0.0,startStopBurst);
}

void BurstyGenerator::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
   FSM_Switch(fsm)
   {
     case FSM_Exit(INIT):
       // transition to SLEEP state
       FSM_Goto(fsm,SLEEP);
       break;
     case FSM_Enter(SLEEP):
       // schedule end of sleep period (start of next burst)
       scheduleAt(simTime()+exponential(sleepTimeMean),
                  startStopBurst);
     break;
     case FSM_Exit(SLEEP):
       // schedule end of this burst
       scheduleAt(simTime()+exponential(burstTimeMean),
                  startStopBurst);
       // transition to ACTIVE state:
       if (msg!=startStopBurst) {
         error("invalid event in state ACTIVE");
       }
       FSM_Goto(fsm,ACTIVE);
       break;
     case FSM_Enter(ACTIVE):
       // schedule next sending
       scheduleAt(simTime()+exponential(sendIATime), sendMessage);
     break;
     case FSM_Exit(ACTIVE):
       // transition to either SEND or SLEEP
       if (msg==sendMessage) {
         FSM_Goto(fsm,SEND);
       } else if (msg==startStopBurst) {
         cancelEvent(sendMessage);
         FSM_Goto(fsm,SLEEP);
       } else {
         error("invalid event in state ACTIVE");
       }
       break;
     case FSM_Exit(SEND): {
       // generate and send out job
       char msgname[32];
       sprintf(msgname, "job-%d", ++i);
       EV &lt;&lt; "Generating " &lt;&lt; msgname &lt;&lt; endl;
       <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *job = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>(msgname);
       job-&gt;setBitLength((long) *msgLength);
       job-&gt;setTimestamp();
       send(job, "out");
       // return to ACTIVE
       FSM_Goto(fsm,ACTIVE);
       break;
     }
   }
}
</pre>

<p>

<p>
<h2><a name="sec:simple-modules:walking-module-hierarchy"/>4.11 Navigating the Module Hierarchy<a class="headerlink" href="#sec:simple-modules:walking-module-hierarchy" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:module-vectors"/>4.11.1 Module Vectors<a class="headerlink" href="#sec:simple-modules:module-vectors" title="Permalink to this headline">¶</a></h3>

<p>If a module is part of a module vector<!--module!vector-->, the
<tt>getIndex()</tt> and <tt>getVectorSize()</tt> member functions can be used to
query its index and the vector size:

<pre class="cpp">
EV &lt;&lt; "This is module [" &lt;&lt; module-&gt;getIndex() &lt;&lt;
      "] in a vector of size [" &lt;&lt; module-&gt;size() &lt;&lt; "].\n";
</pre>
<p>

<p><h3><a name="sec:simple-modules:module-ids"/>4.11.2 Component IDs<a class="headerlink" href="#sec:simple-modules:module-ids" title="Permalink to this headline">¶</a></h3>

<p>Every component (module and channel) in the network has an ID that
can be obtained from <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>'s <tt>getId()</tt> member
function:

<pre class="cpp">
int componentId = getId();
</pre>
<p>
IDs uniquely identify a module or channel for the whole duration of the
simulation. This holds even when modules are created and destroyed
dynamically, because IDs of deleted modules or channels are never reused for
newly created ones.

<p>To look up a component by ID, one needs to use methods of the simulation
manager object, <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>. <tt>getComponent()</tt> expects an ID, and
returns the component's pointer if the component still exists, otherwise it
returns <tt>nullptr</tt>. The method has two variations, <tt>getModule(id)</tt>
and <tt>getChannel(id)</tt>. They return <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>
pointers if the identified component is in fact a module or a channel, respectively,
otherwise they return <tt>nullptr</tt>.

<pre class="cpp">
int id = 100;
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod = getSimulation()-&gt;getModule(id); // exists, and is a module
</pre>
<p>

<p><h3><a name="sec:simple-modules:walking-up-and-down-module-hierarchy"/>4.11.3 Walking Up and Down the Module Hierarchy<a class="headerlink" href="#sec:simple-modules:walking-up-and-down-module-hierarchy" title="Permalink to this headline">¶</a></h3>

<p>The parent module can be accessed by the <tt>getParentModule()</tt>
member function:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *parent = getParentModule();
</pre>
<p>
For example, the parameters of the parent module are accessed
like this:

<pre class="cpp">
double timeout = getParentModule()-&gt;par("timeout");
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>findSubmodule()</tt> and <tt>getSubmodule()</tt>
member functions make it possible to look up the module's submodules
by name<!--module!submodule!lookup--> (or name and index if the submodule
is in a module vector). The first one returns the module ID of
the submodule, and the latter returns the module pointer. If the
submodule is not found, they return -1 or <tt>nullptr</tt>, respectively.

<pre class="cpp">
int submodID = module-&gt;findSubmodule("foo", 3); // look up "foo[3]"
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *submod = module-&gt;getSubmodule("foo", 3);
</pre>
<p>

<p><h3><a name="sec:simple-modules:finding-modules-by-path"/>4.11.4 Finding Modules by Path<a class="headerlink" href="#sec:simple-modules:finding-modules-by-path" title="Permalink to this headline">¶</a></h3>

<p><tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>getModuleByPath()</tt> member function can be used to
find modules by relative or absolute path. It accepts a path string, and
returns the pointer of the matching module, or <tt>nullptr</tt> if the module
identified by the path does not exist.

<p>The path is dot-separated list of module names. The special module name
<tt>^</tt> (caret) stands for the parent module. If the path
starts with a dot or caret, it is understood as relative to this module,
otherwise it is taken to mean an absolute path. For absolute paths,
inclusion of the toplevel module's name in the path is optional.
The toplevel module itself may be referred to as <tt>&lt;root&gt;</tt>.

<p>The following lines demonstrate relative paths, and find the <tt>app[3]</tt>
submodule and the <tt>gen</tt> submodule of the <tt>app[3]</tt> submodule of the
module in question:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *app = module-&gt;getModuleByPath(".app[3]");  // note leading dot
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *gen = module-&gt;getModuleByPath(".app[3].gen");
</pre>
<p>
Without the leading dot, the path is interpreted as absolute. The following
lines both find the <tt>tcp</tt> submodule of <tt>host[2]</tt> in the network,
regardless of the module on which the <tt>getModuleByPath()</tt> has been
invoked.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *tcp = module-&gt;getModuleByPath("Network.host[2].tcp");
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *tcp = module-&gt;getModuleByPath("host[2].tcp");
</pre>
<p>
The parent module may be expressed with a caret:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *parent = module-&gt;getModuleByPath("^"); // parent module
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *tcp = module-&gt;getModuleByPath("^.tcp"); // sibling module
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *other = module-&gt;getModuleByPath("^.^.host[1].tcp"); // two levels up, then...
</pre>
<p>

<p><h3><a name="sec:simple-modules:iterating-over-submodules"/>4.11.5 Iterating over Submodules<a class="headerlink" href="#sec:simple-modules:iterating-over-submodules" title="Permalink to this headline">¶</a></h3>

<p>To access all modules within a compound module,
one can use <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a>::<a href="../api/classomnetpp_1_1cModule_1_1SubmoduleIterator.html">SubmoduleIterator</a></tt>.

<pre class="cpp">
for (<a href="../api/classomnetpp_1_1cModule.html">cModule</a>::<a href="../api/classomnetpp_1_1cModule_1_1SubmoduleIterator.html">SubmoduleIterator</a> it(module); !it.end(); it++)
{
  <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *submodule = *it;
  EV &lt;&lt; submodule-&gt;getFullName() &lt;&lt; endl;
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:navigating-connections"/>4.11.6 Navigating Connections<a class="headerlink" href="#sec:simple-modules:navigating-connections" title="Permalink to this headline">¶</a></h3>

<p>To determine the module at the other end of a connection, use
<tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>'s <tt>getPreviousGate()</tt>, <tt>getNextGate()</tt> and
<tt>getOwnerModule()</tt> methods. An example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *neighbour = gate("out")-&gt;getNextGate()-&gt;getOwnerModule();
</pre>
<p>
For input gates, use <tt>getPreviousGate()</tt> instead of <tt>getNextGate()</tt>.

<p>The endpoints of the connection path are returned by the
<tt>getPathStartGate()</tt> and <tt>getPathEndGate()</tt> <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>
methods. These methods follow the connection path by repeatedly calling
<tt>getPreviousGate()</tt> and <tt>getNextGate()</tt>, respectively,
until they arrive at a <tt>nullptr</tt>. An example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *peer = gate("out")-&gt;getPathEndGate()-&gt;getOwnerModule();
</pre>
<p>

<p><h2><a name="sec:simple-modules:direct-method-calls"/>4.12 Direct Method Calls Between Modules<a class="headerlink" href="#sec:simple-modules:direct-method-calls" title="Permalink to this headline">¶</a></h2>
<!--method calls!between modules-->

<p>In some simulation models, there might be modules which are too
tightly coupled for message-based communication to be efficient.
In such cases, the solution might be calling one simple module's public
C++ methods from another module.

<p>Simple modules are C++ classes, so normal C++ method calls will
work. Two issues need to be mentioned, however:

<p><ul>
  <li> how to get a pointer to the object representing the module;
  <li> how to let the simulation kernel know that a method call across modules
     is taking place.
</ul>

<p>Typically, the called module is in the same compound module as the caller,
so the <tt>getParentModule()</tt> and <tt>getSubmodule()</tt> methods of
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> can be used to get a <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a>*</tt> pointer to the
called module. (Further ways to obtain the pointer are described
in the section <a href="chap4.html#sec:simple-modules:walking-module-hierarchy">[4.11]</a>.)
The <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a>*</tt> pointer then has to be cast to the actual C++ class
of the module, so that its methods become visible.

<p>This makes the following code:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *targetModule = getParentModule()-&gt;getSubmodule("foo");
Foo *target = check_and_cast&lt;Foo *&gt;(targetModule);
target-&gt;doSomething();
</pre>
<p>
The <tt>check_and_cast&lt;&gt;()</tt> template function on the second line
is part of OMNeT++. It performs a standard C++ <tt>dynamic_cast</tt>, and checks
the result: if it is <tt>nullptr</tt>, <tt>check_and_cast</tt> raises an OMNeT++ error.
Using <tt>check_and_cast</tt> saves you from writing error checking
code: if <tt>targetModule</tt> from the first line is <tt>nullptr</tt> because
the submodule named <tt>"foo"</tt> was not found, or if that
module is actually not of type <tt>Foo</tt>, an exception is thrown
from <tt>check_and_cast</tt> with an appropriate error message.<br><ul><font size=-1>[A
<tt>check_and_cast_nullable&lt;&gt;()</tt> function also exists. It
accepts <tt>nullptr</tt> as input, and only complains if the cast
goes wrong.]</font></ul>

<p>The second issue is how to let the simulation kernel know that
a method call across modules is taking place. Why is this necessary
in the first place? First, the simulation kernel always has to know which
module's code is currently executing, in order for ownership handling
and other internal mechanisms to work correctly. Second, the Tkenv and
Qtenv simulation GUIs can animate method calls, but to be able to do that,
they need to know about them. Third, method calls are also recorded
in the event log.

<p>The solution is to add the <tt>Enter_Method()</tt> or <tt>Enter_Method_Silent()</tt>
macro at the top of the methods that may be invoked from other
modules. These calls perform context switching, and, in case of
<tt>Enter_Method()</tt>, notify the simulation GUI so that animation
of the method call can take place. <tt>Enter_Method_Silent()</tt>
does not animate the method call, but otherwise it is equivalent
<tt>Enter_Method()</tt>. Both macros accept a <tt>printf()</tt>-like
argument list (it is optional for <tt>Enter_Method_Silent()</tt>),
which should produce a string with the method name and the
actual arguments as much as practical. The string is displayed in
the animation (<tt>Enter_Method()</tt> only) and recorded into the event log.

<p>
<pre class="cpp">
void Foo::doSomething()
{
    Enter_Method("doSomething()");
    ...
}
</pre>

<p>

<p><h2><a name="sec:simple-modules:creating-modules"/>4.13 Dynamic Module Creation<a class="headerlink" href="#sec:simple-modules:creating-modules" title="Permalink to this headline">¶</a></h2>
<!--module!dynamic creation-->

<p><h3><a name="sec:simple-modules:dynamic-creation:when-to-use"/>4.13.1 When To Use<a class="headerlink" href="#sec:simple-modules:dynamic-creation:when-to-use" title="Permalink to this headline">¶</a></h3>

<p>Certain simulation scenarios require the ability to dynamically create
and destroy modules. For example, simulating the arrival and departure
of new users in a mobile network may be implemented in terms of adding
and removing modules during the course of the simulation. Loading and
instantiating network topology (i.e. nodes and links) from a data file
is another common technique enabled by dynamic module (and link) creation.

<p>OMNeT++ allows both simple and compound modules to be created at runtime.
When instantiating a compound module, its full internal structure
(submodules and internal connections) is reproduced.

<p>Once created and started, dynamic modules aren't any different from
&#8220;static&#8221; modules.

<p>
<h3><a name="sec:simple-modules:dynamic-creation:overview"/>4.13.2 Overview<a class="headerlink" href="#sec:simple-modules:dynamic-creation:overview" title="Permalink to this headline">¶</a></h3>

<p>To understand how dynamic module creation works, you have to know a
bit about how OMNeT++ normally instantiates modules. Each module type
(class) has a corresponding factory object of the class
<tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt>. This object is created under the hood by the
<tt>Define_Module()</tt> macro, and it has a factory
method which can instantiate the module class (this function basically
only consists of a <tt>return new <i>&lt;moduleclass&gt;</i>(...)</tt> statement).

<p>The <tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt> object can be looked up by its name
string (which is the same as the module class name). Once you have its
pointer, it is possible to call its factory method and create an
instance of the corresponding module class -- without having to
include the C++ header file containing module's class declaration
into your source file.

<p>The <tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt> object also knows what gates and
parameters the given module type has to have. (This info comes from
NED files.)

<p>Simple modules can be created in one step. For a compound module, the
situation is more complicated, because its internal structure
(submodules, connections) may depend on parameter values and gate
vector sizes. Thus, for compound modules it is generally required to
first create the module itself, second, set parameter values and gate
vector sizes, and then call the method that creates its submodules and
internal connections.

<p>As you know already, simple modules with <tt>activity()</tt> need a
starter message<!--starter messages-->. For statically created
modules, this message is created automatically by OMNeT++, but for
dynamically created modules, you have to do this explicitly by calling
the appropriate functions.

<p>Calling <tt>initialize()</tt> has to take place after insertion of the
starter messages, because the initializing code may insert new messages
into the FES<!--FES-->, and these messages should be processed
<i>after</i> the starter message.

<p>
<h3><a name="sec:simple-modules:dynamic-creation:api"/>4.13.3 Creating Modules<a class="headerlink" href="#sec:simple-modules:dynamic-creation:api" title="Permalink to this headline">¶</a></h3>

<p>The first step is to find the factory object. The <tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get()</tt>
function expects a fully qualified NED type name, and returns the factory
object:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *moduleType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");
</pre>
<p>
The return value does not need to be checked for <tt>nullptr</tt>, because
the function raises an error if the requested NED type is not found.
(If this behavior is not what you need, you can use the similar
<tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::find()</tt> function, which returns <tt>nullptr</tt> if the type
was not found.)

<p><h4><a name="sec:simple-modules:dynamic:createscheduleinit"/>4.13.3.1 The All-in-One Method<a class="headerlink" href="#sec:simple-modules:dynamic:createscheduleinit" title="Permalink to this headline">¶</a></h4>

<p><tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt> has a
<tt>createScheduleInit(const char *name, <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *parentmod)</tt> % don't break this line (for html)
convenience function to get a module up and running in one step.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod = moduleType-&gt;createScheduleInit("node", this);
</pre>
<p>
<tt>createScheduleInit()</tt> performs the following steps: <tt>create()</tt>,
<tt>finalizeParameters()</tt>, <tt>buildInside()</tt>,
<tt>scheduleStart(now)</tt> and <tt>callInitialize()</tt>.

<p>This method can be used for both simple and compound modules. Its
applicability is somewhat limited, however: because it does everything in
one step, you do not have the chance to set parameters or gate sizes, and
to connect gates before <tt>initialize()</tt> is called.
(<tt>initialize()</tt> expects all parameters and gates to be in place and
the network fully built when it is called.) Because of the above
limitation, this function is mainly useful for creating basic simple
modules.

<p>
<h4><a name="sec:simple-modules:dynamic-creation:details"/>4.13.3.2 The Detailed Procedure<a class="headerlink" href="#sec:simple-modules:dynamic-creation:details" title="Permalink to this headline">¶</a></h4>

<p>If the <tt>createScheduleInit()</tt> all-in-one method is not applicable,
one needs to use the full procedure. It consists of five steps:

<p><ol>
  <li> Find the factory object;
  <li> Create the module;
  <li> Set up its parameters and gate sizes as needed;
  <li> Tell the (possibly compound) module to recursively create
        its internal submodules and connections;
  <li> Schedule activation message(s) for the new simple module(s).
</ol>

<p>Each step (except for Step 3.) can be done with one line of code.

<p>See the following example, where Step 3 is omitted:

<pre class="cpp">
// find factory object
<a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *moduleType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");

// create (possibly compound) module and build its submodules (if any)
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *module = moduleType-&gt;create("node", this);
module-&gt;finalizeParameters();
module-&gt;buildInside();

// create activation message
module-&gt;scheduleStart(simTime());
</pre>
<p>
If you want to set up parameter values or gate vector sizes (Step 3.),
the code goes between the <tt>create()</tt> and
<tt>buildInside()</tt> calls:

<pre class="cpp">
// create
<a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *moduleType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *module = moduleType-&gt;create("node", this);

// set up parameters and gate sizes before we set up its submodules
module-&gt;par("address") = ++lastAddress;
module-&gt;finalizeParameters();

module-&gt;setGateSize("in", 3);
module-&gt;setGateSize("out", 3);

// create internals, and schedule it
module-&gt;buildInside();
module-&gt;scheduleStart(simTime());
</pre>
<p>

<p><h3><a name="sec:simple-modules:deleting-modules"/>4.13.4 Deleting Modules<a class="headerlink" href="#sec:simple-modules:deleting-modules" title="Permalink to this headline">¶</a></h3>

<p>To delete a module dynamically<!--module!dynamic deletion-->, use
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>deleteModule()</tt> member function:

<pre class="cpp">
module-&gt;deleteModule();
</pre>
<p>
If the module was a compound module, this involves recursively
deleting all its submodules. A simple module can also delete itself;
in this case, the <tt>deleteModule()</tt> call does not return to the
caller.

<p>Currently, you cannot safely delete a compound module from a simple module
in it; you must delegate the job to a module outside the compound
module.

<p>
<h3><a name="sec:simple-modules:module-deletion-and-finish"/>4.13.5 Module Deletion and finish()<a class="headerlink" href="#sec:simple-modules:module-deletion-and-finish" title="Permalink to this headline">¶</a></h3>

<p><tt>finish()</tt> is called for <i>all</i> modules at the end of the
simulation, no matter how the modules were created. If a module is
dynamically deleted before that, <tt>finish()</tt> will not be invoked
(<tt>deleteModule()</tt> does not do it). However, you can still manually
invoke it before <tt>deleteModule()</tt>.

<p>You can use the <tt>callFinish()</tt> function to invoke <tt>finish()</tt>
(It is not a good idea to invoke <tt>finish()</tt> directly). If you are
deleting a compound module, <tt>callFinish()</tt> will recursively invoke
<tt>finish()</tt> for all submodules, and if you are deleting a simple
module from another module, <tt>callFinish()</tt> will do the context switch
for the duration of the call.
  <br><ul><font size=-1>[The <tt>finish()</tt> function has even been made <tt>protected</tt>
  in <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>, in order to discourage its invocation from
  other modules.]</font></ul>

<p>Example:

<pre class="cpp">
mod-&gt;callFinish();
mod-&gt;deleteModule();
</pre>
<p>

<p><h3><a name="sec:simple-modules:creating-connections"/>4.13.6 Creating Connections<a class="headerlink" href="#sec:simple-modules:creating-connections" title="Permalink to this headline">¶</a></h3>
<!--connection!creating-->

<p>Connections can be created using <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>'s <tt>connectTo()</tt>
method. <tt>connectTo()</tt> should be invoked on the source gate
of the connection, and expects the destination gate pointer as
an argument. The use of the words <i>source</i> and <i>destination</i>
correspond to the direction of the arrow in NED files.

<pre class="cpp">
srcGate-&gt;connectTo(destGate);
</pre>
<p>
<tt>connectTo()</tt> also accepts a channel object (<tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a>*</tt>) as an
additional, optional argument. Similarly to modules, channels can be
created using their factory objects that have the type <tt><a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a></tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *outGate, *inGate;
...

// find factory object and create a channel
<a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a> *channelType = <a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a>::get("foo.util.Channel");
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *channel = channelType-&gt;create("channel");

// create connecting
outGate-&gt;connectTo(inGate, channel);
</pre>
<p>
The channel object will be owned by the source gate of the connection, and
one cannot reuse the same channel object with several connections.

<p>Instantiating one of the built-in channel types (<tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt>,
<tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> or <tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt>) is somewhat simpler,
because those classes have static <tt>create()</tt> factory functions, and the
step of finding the factory object can be spared. Alternatively, one can use
<tt><a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a></tt>'s <tt>createIdealChannel()</tt>, <tt>createDelayChannel()</tt>
and <tt>createDatarateChannel()</tt> static methods.

<p>The channel object may need to be parameterized before using it for a
connection. For example, <tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> has a <tt>setDelay()</tt>
method, and <tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt> has <tt>setDelay()</tt>,
<tt>setDatarate()</tt>, <tt>setBitErrorRate()</tt> and
<tt>setPacketErrorRate()</tt>.

<p>An example that sets up a channel with a datarate and a delay between two
modules:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a> *datarateChannel = <a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a>::create("channel");
datarateChannel-&gt;setDelay(0.001);
datarateChannel-&gt;setDatarate(1e9);
outGate-&gt;connectTo(inGate, datarateChannel);
</pre>
<p>
Finally, here is a more complete example that creates two modules and
connects them in both directions:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *moduleType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get("TicToc");
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *a = modtype-&gt;createScheduleInit("a", this);
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *b = modtype-&gt;createScheduleInit("b", this);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"));
b-&gt;gate("out")-&gt;connectTo(a-&gt;gate("in"));
</pre>
<p>

<p><h3><a name="sec:simple-modules:removing-connections"/>4.13.7 Removing Connections<a class="headerlink" href="#sec:simple-modules:removing-connections" title="Permalink to this headline">¶</a></h3>
<!--connection!removing-->

<p>The <tt>disconnect()</tt> method of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> can be
used to remove connections. This method has to be invoked
on the <i>source</i> side of the connection. It also destroys
the channel object associated with the connection, if one has been set.

<pre class="cpp">
srcGate-&gt;disconnect();
</pre>
<p>

<p>
<h2><a name="sec:simple-modules:signals"/>4.14 Signals<a class="headerlink" href="#sec:simple-modules:signals" title="Permalink to this headline">¶</a></h2>

<p>This section describes <i>simulation signals</i>, or signals for short.
Signals are a versatile concept that first appeared in OMNeT++ 4.1.

<p>Simulation signals can be used for:

<p><ul>
  <li> exposing statistical properties of the model, without specifying
        whether and how to record them
  <li> receiving notifications about simulation model changes at runtime, and
        acting upon them
  <li> implementing a publish-subscribe style communication among modules;
        this is advantageous when the producer and consumer of the information
        do not know about each other, and possibly there is many-to-one or
        many-to-many relationship among them
  <li> emitting information for other purposes, for example as input for
        custom animation effects
</ul>

<p>Signals are emitted by components (modules and channels). Signals propagate on
the module hierarchy up to the root. At any level, one can register listeners,
that is, objects with callback methods. These listeners will be notified (their
appropriate methods called) whenever a signal value is emitted. The result of
upwards propagation is that listeners registered at a compound module can
receive signals from all components in that submodule tree. A listener
registered at the system module can receive signals from the whole simulation.

<p><ul class="note"><b>NOTE</b><br>
    A channel's parent is the (compound) module that contains the connection,
    not the owner of either gate the channel is connected to.
</ul>

<p>Signals are identified by signal <i>names</i> (i.e. strings), but for efficiency,
at runtime we use dynamically assigned numeric identifiers (<i>signal IDs</i>,
typedef'd as <tt>simsignal_t</tt>). The mapping of signal names to signal IDs is
global, so all modules and channels asking to resolve a particular signal name
will get back the same numeric signal ID.

<p>Listeners can subscribe to signal names or IDs, regardless of their
source. For example, if two different and unrelated module types, say
<tt>Queue</tt> and <tt>Buffer</tt>, both emit a signal named <tt>"length"</tt>, then
a listener that subscribes to <tt>"length"</tt> at some higher compound module
will get notifications from both <tt>Queue</tt> and <tt>Buffer</tt> module
instances. The listener can still look at the source of the signal if it
wants to distinguish the two (it is available as a parameter to the
callback function), but the signals framework itself does not have such a
feature.

<p><ul class="note"><b>NOTE</b><br>
  Because the component type that emits the signal is not part of the signal's
  identity, it is advised to choose signal names carefully. A good naming scheme
  facilitates "merging" of signals that arrive from different sources but
  mean the same thing, and reduces the chance of collisions between signals that
  accidentally have the same name but represent different things.
</ul>

<p>When a signal is emitted, it can carry a <i>value</i> with it. There are
multiple overloaded versions of the <tt>emit()</tt> method for different
data types, and also overloaded <tt>receiveSignal()</tt> methods in
listeners. The signal value can be of selected primitive types, or an
object pointer; anything that is not feasible to emit as a primitive type
may be wrapped into an object, and emitted as such.

<p>Even when the signal value is of a primitive type, it is possible to convey
extra information to listeners via an additional <i>details</i> object,
which an optional argument of <tt>emit()</tt>.

<p>
<h3><a name="sec:simple-modules:signals-design"/>4.14.1 Design Considerations and Rationale<a class="headerlink" href="#sec:simple-modules:signals-design" title="Permalink to this headline">¶</a></h3>

<p>The implementation of signals is based on the following assumptions:

<p><ul>
  <li> subscribe/unsubscribe operations are rare compared to <tt>emit()</tt>
    calls, so it is <tt>emit()</tt> that needs to be efficient
  <li> the signals mechanism is present in every module, so per-module
    memory overhead must be kept as low as possible
  <li> it is expected that modules and channels will be heavily instrumented
    with signals, and only a subset of signals will actually be used
    (will have listeners) in any particular simulation; therefore,
    the CPU and memory overhead of momentarily unused signals must be
    as low as possible
</ul>

<p>These goals have been achieved in the 4.1 version with the following
implementation. First, the data structure that used to store listeners in
components is dynamically allocated, so if there are no listeners, the
per-component overhead is only the size of the pointer (which will be
<tt>nullptr</tt> then).

<p>Second, additionally there are two bitfields in every component that store
which one of the first 64 signals (IDs 0..63) have local listeners and
listeners in ancestor modules.<br><ul><font size=-1>[It is assumed that there will be
typically less than 64 frequently used signals used at a time in a
simulation.]</font></ul> Using these bitfields, it is possible to determine in constant
time for the first 64 signals whether the signal has listeners, so
<tt>emit()</tt> can return immediately if there are none. For other signals,
<tt>emit()</tt> needs to examine the listener lists up to the root every
time. Even if a simulation uses more than 64 signals, in
performance-critical situations it is possible to arrange that frequently
emitted signals (e.g. <tt>"txBegin"</tt>) get the &#8220;fast&#8221; signal IDs, while
infrequent signals (like e.g. <tt>"routerDown"</tt>) get the rest.

<p>
<h3><a name="sec:simple-modules:signals-api"/>4.14.2 The Signals Mechanism<a class="headerlink" href="#sec:simple-modules:signals-api" title="Permalink to this headline">¶</a></h3>

<p>Signal-related methods are declared on <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>, so they are available
for both <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>.

<p><h4><a name="sec:simple-modules:signal-ids"/>4.14.2.1 Signal IDs<a class="headerlink" href="#sec:simple-modules:signal-ids" title="Permalink to this headline">¶</a></h4>

<p>Signals are identified by names, but internally numeric signal IDs are used
for efficiency. The <tt>registerSignal()</tt> method takes a signal name as
parameter, and returns the corresponding <tt>simsignal_t</tt> value.
The method is static, illustrating the fact that signal names are global.
An example:

<pre class="cpp">
simsignal_t lengthSignalId = registerSignal("length");
</pre>
<p>
The <tt>getSignalName()</tt> method (also static) does the reverse:
it accepts a <tt>simsignal_t</tt>, and returns the name of the signal as
<tt>const char *</tt> (or <tt>nullptr</tt> for invalid signal handles):

<pre class="cpp">
const char *signalName = getSignalName(lengthSignalId); // --&gt; "length"
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Since OMNeT++ 4.3, the lifetime of signal IDs is the entire program, and
  it is possible to call <tt>registerSignal()</tt> from initializers of
  global variables, e.g. static class members. In earlier versions,
  signal IDs were usually allocated in <tt>initialize()</tt>, and were
  only valid for that simulation run.
</ul>

<p><h4><a name="sec:simple-modules:emitting-signals"/>4.14.2.2 Emitting Signals<a class="headerlink" href="#sec:simple-modules:emitting-signals" title="Permalink to this headline">¶</a></h4>

<p>The <tt>emit()</tt> family of functions emit a signal from the module or
channel. <tt>emit()</tt> takes a signal ID (<tt>simsignal_t</tt>) and
a value as parameters:

<pre class="cpp">
emit(lengthSignalId, queue.length());
</pre>
<p>
The value can be of type <tt>bool</tt>, <tt>long</tt>, <tt>double</tt>, <tt>simtime_t</tt>,
<tt>const char *</tt>, or <tt>(const) <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *</tt>. Other types can be cast into
one of these types, or wrapped into an object subclassed from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.

<p><tt>emit()</tt> also has an extra, optional object pointer argument named
<tt>details</tt>, with the type <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a>*</tt>. This argument may be used
to convey to listeners extra information.

<p><ul class="note"><b>NOTE</b><br>
  The <i>details</i> parameter was added in OMNeT++ 5.0. You should update
  your models to use the new listener interface or as a temporary solution, compile
  OMNeT++ with the <tt>WITH_OMNETPP4x_LISTENER_SUPPORT</tt> macro.
</ul>

<p>When there are no listeners, the runtime cost of <tt>emit()</tt> is usually minimal.
However, if producing a value has a significant runtime cost, then the
<tt>mayHaveListeners()</tt> or <tt>hasListeners()</tt> method can be used
to check beforehand whether the given signal has any listeners at all --
if not, producing the value and emitting the signal can be skipped.

<p>Example usage:

<pre class="cpp">
if (mayHaveListeners(distanceToTargetSignal)) {
    double d = sqrt((x-targetX)*(x-targetX) + (y-targetY)*(y-targetY));
    emit(distanceToTargetSignal, d);
}
</pre>
<p>
The <tt>mayHaveListeners()</tt> method is very efficient (a constant-time
operation), but may return false positive. In contrast,
<tt>hasListeners()</tt> will search up to the top of the module tree if
the answer is not cached, so it is generally slower. We recommend that
you take into account the cost of producing notification information when
deciding between <tt>mayHaveListeners()</tt> and <tt>hasListeners()</tt>.

<p>
<h4><a name="sec:simple-modules:signal-declarations"/>4.14.2.3 Signal Declarations<a class="headerlink" href="#sec:simple-modules:signal-declarations" title="Permalink to this headline">¶</a></h4>

<p>Since OMNeT++ 4.4, signals can be declared in NED files for documentation
purposes, and OMNeT++ can check that only declared signals are emitted,
and that they actually conform to the declarations (with regard to the
data type, etc.)

<p>The following example declares a queue module that emits a signal named
<tt>queueLength</tt>:

<pre class="ned">
simple Queue
{
    parameters:
        @signal[queueLength](type=long);
        ...
}
</pre>
<p>
Signals are declared with the <b><tt>@signal</tt></b> property on
the module or channel that emits it. (NED properties are described in
<a href="chap3.html#sec:ned-lang:properties">[3.12]</a>). The property index corresponds
to the signal name, and the property's body may declare various attributes
of the signal; currently only the data type is supported.

<p>The <tt>type</tt> property key is optional; when present, its value should be
<tt>bool</tt>, <tt>long</tt>, <tt>unsigned long</tt>, <tt>double</tt>, <tt>simtime_t</tt>,
<tt>string</tt>, or a registered class name optionally followed by a question
mark. Classes can be registered using the <tt>Register_Class()</tt> or
<tt>Register_Abstract_Class()</tt> macros; these macros create a
<tt><a href="../api/classomnetpp_1_1cObjectFactory.html">cObjectFactory</a></tt> instance, and the simulation kernel will call
<tt><a href="../api/classomnetpp_1_1cObjectFactory.html">cObjectFactory</a></tt>'s <tt>isInstance()</tt> method to check that the
emitted object is really a subclass of the declared class.
<tt>isInstance()</tt> just wraps a C++ <tt>dynamic_cast</tt>.)

<p>A question mark after the class name means that the signal is allowed to
emit <tt>nullptr</tt> pointers. For example, a module named <tt>PPP</tt> may emit
the frame (packet) object every time it starts transmiting, and emit
<tt>nullptr</tt> when the transmission is completed:

<pre class="ned">
simple PPP
{
    parameters:
        @signal[txFrame](type=PPPFrame?);  // a PPPFrame or nullptr
        ...
}
</pre>
<p>
The property index may contain wildcards, which is important for declaring
signals whose names are only known at runtime. For example, if a module emits
signals called <tt>session-1-seqno</tt>, <tt>session-2-seqno</tt>, <tt>session-3-seqno</tt>,
etc., those signals can be declared as:

<pre class="ned">
    @signal[session-*-seqno]();
</pre>
<p>

<p><h4><a name="sec:simple-modules:enabling-signal-checking"/>4.14.2.4 Enabling/Disabling Signal Checking<a class="headerlink" href="#sec:simple-modules:enabling-signal-checking" title="Permalink to this headline">¶</a></h4>

<p>Starting with OMNeT++ 5.0, signal checking is turned on by default when the
simulation kernel is compiled in debug mode, requiring all signals to be
declared with <b><tt>@signal</tt></b>. (It is turned off in release mode
simulation kernels due to performance reasons.)

<p>If needed, signal checking can be disabled with the <b><tt>check-signals</tt></b>
configuration option:

<pre class="inifile">
check-signals = false
</pre>
<p>

<p><h4><a name="sec:simple-modules:signal-data-objects"/>4.14.2.5 Signal Data Objects<a class="headerlink" href="#sec:simple-modules:signal-data-objects" title="Permalink to this headline">¶</a></h4>

<p>When emitting a signal with a <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a>*</tt> pointer, you can pass as data
an object that you already have in the model, provided you have a suitable
object at hand. However, it is often necessary to declare a custom class
to hold all the details, and fill in an instance just for the purpose of
emitting the signal.

<p>The custom notification class must be derived from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.
We recommend that you also add <tt><a href="../api/classomnetpp_1_1noncopyable.html">noncopyable</a></tt> as a base class, because
then you don't need to write a copy constructor, assignment operator, and
<tt>dup()</tt> function, sparing some work. When emitting the signal, you
can create a temporary object, and pass its pointer to the <tt>emit()</tt>
function.

<p>An example of custom notification classes are the ones associated with
model change notifications (see <a href="chap4.html#sec:simple-modules:model-change">[4.14.3]</a>).
For example, the data class that accompanies a signal that announces that a
gate or gate vector is about to be created looks like this:

<pre class="cpp">
class <a href="../api/classomnetpp_1_1cPreGateAddNotification.html">cPreGateAddNotification</a> : public <a href="../api/classomnetpp_1_1cObject.html">cObject</a>, <a href="../api/classomnetpp_1_1noncopyable.html">noncopyable</a>
{
  public:
    <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *module;
    const char *gateName;
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a>::Type gateType;
    bool isVector;
};
</pre>
<p>
And the code that emits the signal:

<pre class="cpp">
if (hasListeners(PRE_MODEL_CHANGE))
{
    <a href="../api/classomnetpp_1_1cPreGateAddNotification.html">cPreGateAddNotification</a> tmp;
    tmp.module = this;
    tmp.gateName = gatename;
    tmp.gateType = type;
    tmp.isVector = isVector;
    emit(PRE_MODEL_CHANGE, &tmp);
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:subscribing-to-signals"/>4.14.2.6 Subscribing to Signals<a class="headerlink" href="#sec:simple-modules:subscribing-to-signals" title="Permalink to this headline">¶</a></h4>

<p>The <tt>subscribe()</tt> method registers a listener for a signal.
Listeners are objects that extend the <tt><a href="../api/classomnetpp_1_1cIListener.html">cIListener</a></tt> class.
The same listener object can be subscribed to multiple signals.
<tt>subscribe()</tt> has two arguments: the signal and a pointer to
the listener object:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a> *listener = ...;
simsignal_t lengthSignalId = registerSignal("length");
subscribe(lengthSignalId, listener);
</pre>
<p>
For convenience, the <tt>subscribe()</tt> method has a variant
that takes the signal name directly, so the <tt>registerSignal()</tt>
call can be omitted:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a> *listener = ...;
subscribe("length", listener);
</pre>
<p>
One can also subscribe at other modules, not only the local one.
For example, in order to get signals from all parts of the model,
one can subscribe at the system module level:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a> *listener = ...;
getSimulation()-&gt;getSystemModule()-&gt;subscribe("length", listener);
</pre>
<p>
The <tt>unsubscribe()</tt> method has the same parameter list
as <tt>subscribe()</tt>, and unregisters the given listener
from the signal:

<pre class="cpp">
unsubscribe(lengthSignalId, listener);
</pre>
<p>
or

<pre class="cpp">
unsubscribe("length", listener);
</pre>
<p>
It is an error to subscribe the same listener to the same
signal twice.

<p><ul class="note"><b>NOTE</b><br>
  When a listener is deleted, it must already be unsubscribed from
  all components it has subscribed to. This is explained in
  <a href="chap4.html#sec:simple-modules:signals:life-cycle">[4.14.2.8]</a>.
</ul>

<p>It is possible to test whether a listener is subscribed to a signal,
using the <tt>isSubscribed()</tt> method which also takes the same
parameter list.

<pre class="cpp">
if (isSubscribed(lengthSignalId, listener))
{
    ...
}
</pre>
<p>
For completeness, there are methods for getting the list of signals
that the component has subscribed to (<tt>getLocalListenedSignals()</tt>),
and the list of listeners for a given signal (<tt>getLocalSignalListeners()</tt>).
The former returns <tt>std::vector&lt;simsignal_t&gt;</tt>; the latter takes
a signal ID (<tt>simsignal_t</tt>) and returns <tt>std::vector&lt;<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a>*&gt;</tt>.

<p>The following example prints the number of listeners for each signal:

<pre class="cpp">
EV &lt;&lt; "Signal listeners:\n";
std::vector&lt;simsignal_t&gt; signals = getLocalListenedSignals();
for (unsigned int i = 0; i &lt; signals.size(); i++) {
    simsignal_t signalID = signals[i];
    std::vector&lt;<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a>*&gt; listeners = getLocalSignalListeners(signalID);
    EV &lt;&lt; getSignalName(signalID) &lt;&lt; ": " &lt;&lt; listeners.size() &lt;&lt; " signals\n";
}
</pre>
<p>
<h4><a name="sec:simple-modules:signal-listeners"/>4.14.2.7 Listeners<a class="headerlink" href="#sec:simple-modules:signal-listeners" title="Permalink to this headline">¶</a></h4>

<p>Listeners are objects that subclass from the <tt><a href="../api/classomnetpp_1_1cIListener.html">cIListener</a></tt> class, which
declares the following methods:

<pre class="cpp">
class <a href="../api/classomnetpp_1_1cIListener.html">cIListener</a>
{
  public:
    virtual ~<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a>() {}
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               bool value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               long value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               double value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               simtime_t value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               const char *value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void finish(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *component, simsignal_t id) {}
    virtual void subscribedTo(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *component, simsignal_t id) {}
    virtual void unsubscribedFrom(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *component, simsignal_t id) {}
};
</pre>
<p>
This class has a number of virtual methods:

<p><ul>
  <li> Several overloaded <tt>receiveSignal()</tt> methods, one for each
    data type. Whenever a signal is emitted (via <tt>emit()</tt>), the matching
    <tt>receiveSignal()</tt> method is invoked on the subscribed listeners.
  <li> <tt>finish()</tt> is called by a component on its local listeners
    after the component's <tt>finish()</tt> method was called. If the listener
    is subscribed to multiple signals or at multiple components, the method
    will be called multiple times. Note that <tt>finish()</tt> methods in general
    are not invoked if the simulation terminates with an error, so that method
    is not a place for doing cleanup.
  <li> <tt>subscribedTo()</tt>, <tt>unsubscribedFrom()</tt> are called
    when this listener object is subscribed/unsubscribed to (from) a signal.
    These methods give the opportunity for listeners to track whether
    and where they are subscribed. It is also OK for a listener to delete
    itself in the last statement of the <tt>unsubscribedFrom()</tt> method,
    but you must be sure that there are no other places the same listener
    is still subscribed.
</ul>

<p>Since <tt><a href="../api/classomnetpp_1_1cIListener.html">cIListener</a></tt> has a large number of pure virtual methods, it is more
convenient to subclass from <tt><a href="../api/classomnetpp_1_1cListener.html">cListener</a></tt>, a do-nothing implementation
instead. It defines <tt>finish()</tt>, <tt>subscribedTo()</tt> and
<tt>unsubscribedFrom()</tt> with an empty body, and the <tt>receiveSignal()</tt>
methods with a bodies that throw a <tt>"Data type not supported"</tt> error.
You can redefine the <tt>receiveSignal()</tt> method(s) whose data type
you want to support, and signals emitted with other (unexpected) data
types will result in an error instead of going unnoticed.

<p>The order in which listeners will be notified is undefined (it is not necessarily
the same order in which listeners were subscribed.)

<p><h4><a name="sec:simple-modules:signals:life-cycle"/>4.14.2.8 Listener Life Cycle<a class="headerlink" href="#sec:simple-modules:signals:life-cycle" title="Permalink to this headline">¶</a></h4>

<p>When a component (module or channel) is deleted, it automatically
unsubscribes (but does not delete) the listeners it has. When a
module is deleted, it first unsubscribes all listeners from all
modules and channels in its submodule tree before starting
to recursively delete the modules and channels themselves.

<p>When a listener is deleted, it must already be unsubscribed from all
components at that point. If it is not unsubscribed, pointers to the dead
listener object will be left in the components' listener lists, and the
components will crash inside an <tt>emit()</tt> call, or when they
try to invoke <tt>unsubscribedFrom()</tt> on the dead listener from their
destructors. The <tt><a href="../api/classomnetpp_1_1cIListener.html">cIListener</a></tt> class contains a subscription count,
and prints a warning message when it is not zero in the destructor.

<p><ul class="note"><b>NOTE</b><br>
  If your module has added listeners to other modules (e.g. the toplevel
  module), these listeners must be unsubscribed in the module
  destructor at latest. Remember to make sure the modules still exist before you
  call <tt>unsubscribe()</tt> on them, unless they are an ancestor
  of your module in the module tree.
</ul>

<p>
<h3><a name="sec:simple-modules:model-change"/>4.14.3 Listening to Model Changes<a class="headerlink" href="#sec:simple-modules:model-change" title="Permalink to this headline">¶</a></h3>

<p>In simulation models it is often useful to hold references to other
modules, a connecting channel or other objects, or to cache information
derived from the model topology. However, such pointers or data may
become invalid when the model changes at runtime, and need to be updated
or recalculated. The problem is how to get notification that something has
changed in the model.

<p><ul class="note"><b>NOTE</b><br>
  Whenever you see a <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a>*</tt>, <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a>*</tt>, <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>*</tt> or
  similar pointer kept as state in a simple module, you should think about
  how it will be kept up-to-date if the model changes at runtime.
</ul>

<p>The solution is, of course, signals. OMNeT++ has two built-in signals,
<tt>PRE_MODEL_CHANGE</tt> and <tt>POST_MODEL_CHANGE</tt> (these macros
are <tt>simsignal_t</tt> values, not names) that are emitted before and
after each model change.

<p>Pre/post model change notifications are emitted with data objects that
carry the details of the change. The data classes are:

<p><ul>
  <li> <tt><a href="../api/classomnetpp_1_1cPreModuleAddNotification.html">cPreModuleAddNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostModuleAddNotification.html">cPostModuleAddNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostModuleDeleteNotification.html">cPostModuleDeleteNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreModuleReparentNotification.html">cPreModuleReparentNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostModuleReparentNotification.html">cPostModuleReparentNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateAddNotification.html">cPreGateAddNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateAddNotification.html">cPostGateAddNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateDeleteNotification.html">cPreGateDeleteNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateDeleteNotification.html">cPostGateDeleteNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateVectorResizeNotification.html">cPreGateVectorResizeNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateVectorResizeNotification.html">cPostGateVectorResizeNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateConnectNotification.html">cPreGateConnectNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateConnectNotification.html">cPostGateConnectNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateDisconnectNotification.html">cPreGateDisconnectNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateDisconnectNotification.html">cPostGateDisconnectNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPrePathCreateNotification.html">cPrePathCreateNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostPathCreateNotification.html">cPostPathCreateNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPrePathCutNotification.html">cPrePathCutNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostPathCutNotification.html">cPostPathCutNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreParameterChangeNotification.html">cPreParameterChangeNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostParameterChangeNotification.html">cPostParameterChangeNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreDisplayStringChangeNotification.html">cPreDisplayStringChangeNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostDisplayStringChangeNotification.html">cPostDisplayStringChangeNotification</a></tt>
</ul>

<p>They all subclass from <tt><a href="../api/classomnetpp_1_1cModelChangeNotification.html">cModelChangeNotification</a></tt>, which is of course a
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>. Inside the listener, you can use <tt>dynamic_cast&lt;&gt;</tt> to figure
out what notification arrived.

<p><ul class="note"><b>NOTE</b><br>
  Please look up these classes in the API documentation to see their data fields,
  when exactly they get fired, and what one needs to be careful about when using them.
</ul>

<p>An example listener that prints a message when a module is deleted:

<pre class="cpp">
class MyListener : public <a href="../api/classomnetpp_1_1cListener.html">cListener</a>
{
   ...
};

void MyListener::receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *value,
                               <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details)
{
    if (dynamic_cast&lt;<a href="../api/classomnetpp_1_1cPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *&gt;(value)) {
        <a href="../api/classomnetpp_1_1cPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *data = (<a href="../api/classomnetpp_1_1cPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *)value;
        EV &lt;&lt; "Module " &lt;&lt; data-&gt;module-&gt;getFullPath() &lt;&lt; " is about to be deleted\n";
    }
}
</pre>
<p>
If you'd like to get notification about the deletion of any module, you need
to install the listener on the system module:

<pre class="cpp">
getSimulation()-&gt;getSystemModule()-&gt;subscribe(PRE_MODEL_CHANGE, listener);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  <tt>PRE_MODEL_CHANGE</tt> and <tt>POST_MODEL_CHANGE</tt> are fired on the
  module (or channel) affected by the change, and <i>not</i> on the module
  which executes the code that causes the change. For example,
  <i>pre-module-deleted</i> is fired on the module to be removed, and
  <i>post-module-deleted</i> is fired on its parent (because the original
  module no longer exists), and not on the module that contains the
  <tt>deleteModule()</tt> call.
</ul>

<p><ul class="note"><b>NOTE</b><br>
  A listener will <i>not</i> receive <i>pre/post-module-deleted</i>
  notifications if the whole submodule tree that contains the subscription
  point is deleted. This is because compound module destructors begin
  by unsubscribing all modules/channels in the subtree before starting
  recursive deletion.
</ul>

<p>
<h2><a name="sec:simple-modules:signal-based-statistics"/>4.15 Signal-Based Statistics Recording<a class="headerlink" href="#sec:simple-modules:signal-based-statistics" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:signal-based-statistics-motivation"/>4.15.1 Motivation<a class="headerlink" href="#sec:simple-modules:signal-based-statistics-motivation" title="Permalink to this headline">¶</a></h3>

<p>One use of signals is to expose variables for result collection without
telling where, how, and whether to record them. With this approach,
modules only publish the variables, and the actual result recording
takes place in listeners. Listeners may be added by the simulation
framework (based on the configuration), or by other modules (for example
by dedicated result collection modules).

<p>The signals approach allows for several possibilities:

<p><ul>
 <li> Provides a controllable level of detail: in some simulation runs
    you may want to record all values as a time series, in other runs
    only record the mean, time average, minimum/maximum value, standard
    deviation etc, and in yet other runs you may want to record the
    distribution as a histogram;
 <li> Depending on the purpose of the simulation experiment, you may want
    to process the results before recording them, for example
    record a smoothed or filtered value, record the percentage of time the
    value is nonzero or over a threshold, record the sum of the values, etc.;
 <li> You may want aggregate statistics, e.g. record the total number
    of packet drops or the average end-to-end delay for the whole network;
 <li> You may want to record combined statistics, for example a drop
    percentage (drop count/total number of packets);
 <li> You may want to ignore results generated during the warm-up period
    or during other transients.
</ul>

<p>With the signals approach the above goals can be fulfilled.

<p>
<h3><a name="sec:simple-modules:declaring-statistics"/>4.15.2 Declaring Statistics<a class="headerlink" href="#sec:simple-modules:declaring-statistics" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:declared-statistics:introduction"/>4.15.2.1 Introduction<a class="headerlink" href="#sec:simple-modules:declared-statistics:introduction" title="Permalink to this headline">¶</a></h4>

<p>In order to record simulation results based on signals, one must add
<b><tt>@statistic</tt></b> properties to the simple module's (or channel's) NED
definition. A <b><tt>@statistic</tt></b> property defines the name of the
statistic, which signal(s) are used as input, what processing steps are to
be applied to them (e.g. smoothing, filtering, summing, differential
quotient), and what properties are to be recorded (minimum, maximum,
average, etc.) and in which form (vector, scalar, histogram). Record items
can be marked optional, which lets you denote a <i>&#8220;default&#8221;</i> and a
more comprehensive <i>&#8220;all&#8221;</i> result set to be recorded; the list of
record items can be further tweaked from the configuration. One can also
specify a descriptive name (&#8220;title&#8221;) for the statistic, and also a
measurement unit.

<p>The following example declares a queue module with a queue length statistic:

<pre class="ned">
simple Queue
{
    parameters:
        @statistic[queueLength](record=max,timeavg,vector?);
    gates:
        input in;
        output out;
}
</pre>
<p>
As you can see, statistics are represented with indexed NED properties (see
<a href="chap3.html#sec:ned-lang:properties">[3.12]</a>). The property name is always
<tt>statistic</tt>, and the index (here, <tt>queueLength</tt>) is the
name of the statistic. The property value, that is, everything inside the
parentheses, carries hints and extra information for recording.

<p>The above <tt>@statistic</tt> declaration assumes that module's C++ code
emits the queue's updated length as signal <tt>queueLength</tt> whenever
elements are inserted into the queue or are removed from it.
By default, the maximum and the time average of the queue length will
be recorded as scalars. One can also instruct the simulation (or parts
of it) to record &#8220;all&#8221; results; this will turn on optional record items,
those marked with a question mark, and then the queue lengths will also be
recorded into an output vector.

<p><ul class="note"><b>NOTE</b><br>
The configuration lets you fine-tune the list of result items even
beyond the <tt>default</tt> and <tt>all</tt> settings; see section
<a href="chap12.html#sec:ana-sim:configuring-recording-modes">[12.2.3]</a>.
</ul>

<p>In the above example, the signal to be recorded was taken from the
statistic name. When that is not suitable, the <tt>source</tt> property key
lets you specify a different signal as input for the statistic. The
following example assumes that the C++ code emits a <tt>qlen</tt> signal, and
declares a <tt>queueLength</tt> statistic based on that:

<pre class="ned">
simple Queue
{
    parameters:
        @signal[qlen](type=int); // optional
        @statistic[queueLength](source=qlen; record=max,timeavg,vector?);
        ...
}
</pre>
<p>
Note that beyond the <tt>source=qlen</tt> property key we have also added
a signal declaration (<b><tt>@signal</tt></b> property) for the <tt>qlen</tt> signal.
Declaring signals is currently optional and in fact <tt>@signal</tt> properties
are currently ignored by the system, but it is a good practice nevertheless.

<p>It is also possible to apply processing to a signal before recording it.
Consider the following example:

<pre class="ned">
@statistic[dropCount](source=count(drop); record=last,vector?);
</pre>
<p>
This records the total number of packet drops as a scalar, and
optionally the number of packets dropped in the function of time as a
vector, provided the C++ code emits a <tt>drop</tt> signal every time a packet
is dropped. The value and even the data type of the <tt>drop</tt> signal is
indifferent, because only the number of emits will be counted.
Here, <tt>count()</tt> is a <i>result filter</i>.

<p><ul class="note"><b>NOTE</b><br>
Starting from OMNeT++ 4.4, items containing parens (e.g. <tt>count(drop)</tt>)
no longer need to be enclosed in quotation marks.
</ul>

<p>Another example:

<pre class="ned">
@statistic[droppedBytes](source=sum(packetBytes(pkdrop)); record=last,
vector?);
</pre>
<p>
This example assumes that the C++ code emits a <tt>pkdrop</tt> signal with a
packet (<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>*</tt> pointer) as a value. Based on that signal, it
records the total number of bytes dropped (as a scalar, and optionally as a
vector too). The <tt>packetBytes()</tt> filter extracts the number of bytes
from each packet using <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>'s <tt>getByteLength()</tt> method,
and the <tt>sum()</tt> filter, well, sums them up.

<p>Arithmetic expressions can also be used. For example, the following line
computes the number of dropped bytes using the <tt>packetBits()</tt> filter.

<pre class="ned">
@statistic[droppedBytes](source=sum(8*packetBits(pkdrop)); record=last,
vector?);
</pre>
<p>
The source can also combine multiple signals in an arithmetic expression:

<pre class="ned">
@statistic[dropRate](source=count(drop)/count(pk); record=last,vector?);
</pre>
<p>
When multiple signals are used, a value arriving on either signal will
result in one output value. The computation will use the last values of the
other signals (sample-hold interpolation). One limitation regarding
multiple signals is that the same signal cannot occur twice, because it
would cause glitches in the output.

<p>Record items may also be expressions and contain filters. For example, the
statistic below is functionally equivalent to one of the above examples: it
also computes and records as scalar and as vector the total number of bytes
dropped, using a <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>*</tt>-valued signal as input; however, some of
the computations have been shifted into the recorder part.

<pre class="ned">
@statistic[droppedBytes](source=packetBits(pkdrop); record=last(8*sum),
vector(8*sum)?);
</pre>
<p>

<p><h4><a name="sec:simple-modules:declared-statistics:property-keys"/>4.15.2.2 Property Keys<a class="headerlink" href="#sec:simple-modules:declared-statistics:property-keys" title="Permalink to this headline">¶</a></h4>

<p>The following keys are understood in <b><tt>@statistic</tt></b> properties:

<p><ul class="dl">
  <li><b>source</b> : Defines the input for the recorders (see <tt>record=</tt> key).
     When missing, the statistic name is taken as the signal name;
  <li><b>record</b> : Contains a list of recording modes, separated by comma.
     Recording modes define how to record the source (see <tt>source=</tt> key).
  <li><b>title</b> : A longer, descriptive name for the statistic signal; result
      visualization tools may use it as chart label, e.g. in the legend.
  <li><b>unit</b> : Measurement unit of the values. This may also appear in charts.
  <li><b>interpolationmode</b> : Defines how to interpolate signal values where
      needed (e.g. for drawing); possible values are <tt>none</tt>,
      <tt>sample-hold</tt>, <tt>backward-sample-hold</tt>, <tt>linear</tt>.
  <li><b>enum</b> : Defines symbolic names for various integer signal values.
      The property value must be a string, containing <i>name=value</i> pairs
      separated by comma. Example: <tt>"IDLE=1,BUSY=2,DOWN=3"</tt>.
</ul>

<p>
<h4><a name="sec:simple-modules:available-result-filters-and-recorders"/>4.15.2.3 Available Filters and Recorders<a class="headerlink" href="#sec:simple-modules:available-result-filters-and-recorders" title="Permalink to this headline">¶</a></h4>

<p>The following table contains the list of predefined result filters.
All filters in the table output a value for each input value.

<p><table border>
<TR> <TD align=left>
  
<p>  <b>Filter</b> </TD> <TD align=left> <b>Description</b> </TD></TR>
<TR> <TD align=left>   <tt>count</tt> </TD> <TD align=left> Computes and outputs the count of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>sum</tt> </TD> <TD align=left> Computes and outputs the sum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>min</tt> </TD> <TD align=left> Computes and outputs the minimum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>max</tt> </TD> <TD align=left> Computes and outputs the maximum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>mean</tt> </TD> <TD align=left> Computes and outputs the average (sum / count) of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>timeavg</tt> </TD> <TD align=left> Regards the input values and their timestamps as a step function (sample-hold style), and
                  computes and outputs its time average (integral divided by duration). </TD></TR>
<TR> <TD align=left>   <tt>constant0</tt> </TD> <TD align=left> Outputs a constant 0 for each received value (independent of the value). </TD></TR>
<TR> <TD align=left>   <tt>constant1</tt> </TD> <TD align=left> Outputs a constant 1 for each received value (independent of the value). </TD></TR>
<TR> <TD align=left>   <tt>packetBits</tt> </TD> <TD align=left> Expects <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> pointers as value, and outputs the bit length
                     for each received one. Non-<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> values are ignored. </TD></TR>
<TR> <TD align=left>   <tt>packetBytes</tt> </TD> <TD align=left> Expects <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> pointers as value, and outputs the byte length
                      for each received one. Non-<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> values are ignored. </TD></TR>
<TR> <TD align=left>   <tt>sumPerDuration</tt> </TD> <TD align=left> For each value, computes the sum of values received so far,
                         divides it by the duration, and outputs the result. </TD></TR>
<TR> <TD align=left>   <tt>removeRepeats</tt> </TD> <TD align=left> Removes repeated values, i.e. discards values that are the same as the previous value. </TD></TR>
</table>

<p>The list of predefined result recorders:

<p><table border>
<TR> <TD align=left>
  
<p>  <b>Recorder</b> </TD> <TD align=left> <b>Description</b> </TD></TR>
<TR> <TD align=left>   <tt>last</tt> </TD> <TD align=left> Records the last value into an output scalar. </TD></TR>
<TR> <TD align=left>   <tt>count</tt> </TD> <TD align=left> Records the count of the input values into an output scalar;
                functionally equivalent to <tt>last(count)</tt> </TD></TR>
<TR> <TD align=left>   <tt>sum</tt> </TD> <TD align=left> Records the sum of the input values into an output scalar
              (or zero if there was none);
              functionally equivalent to <tt>last(sum)</tt> </TD></TR>
<TR> <TD align=left>   <tt>min</tt> </TD> <TD align=left> Records the minimum of the input values into an output scalar
              (or positive infinity if there was none);
              functionally equivalent to <tt>last(min)</tt> </TD></TR>
<TR> <TD align=left>   <tt>max</tt> </TD> <TD align=left> Records the maximum of the input values into an output scalar
              (or negative infinity if there was none);
              functionally equivalent to <tt>last(max)</tt> </TD></TR>
<TR> <TD align=left>   <tt>mean</tt> </TD> <TD align=left> Records the mean of the input values into an output scalar
               (or NaN if there was none);
               functionally equivalent to <tt>last(mean)</tt> </TD></TR>
<TR> <TD align=left>   <tt>timeavg</tt> </TD> <TD align=left> Regards the input values with their timestamps as a step
               function (sample-hold style), and records the time average of the
               input values into an output scalar;
               functionally equivalent to <tt>last(timeavg)</tt> </TD></TR>
<TR> <TD align=left>   <tt>stats</tt> </TD> <TD align=left> Computes basic statistics (count, mean, std.dev, min, max) from the input values,
                and records them into the output scalar file as a statistic object. </TD></TR>
<TR> <TD align=left>   <tt>histogram</tt> </TD> <TD align=left> Computes a histogram and basic statistics (count, mean, std.dev, min, max)
                from the input values, and records the reslut into the output scalar file
                as a histogram object. </TD></TR>
<TR> <TD align=left>   <tt>vector</tt> </TD> <TD align=left> Records the input values with their timestamps into an output vector. </TD></TR>
</table>

<p><ul class="note"><b>NOTE</b><br>
You can have the list of available result filters and result recorders
printed by executing the <tt>opp_run -h resultfilters</tt> and <tt>opp_run
-h resultrecorders</tt> commands.
</ul>

<p>
<h4><a name="sec:simple-modules:naming-and-attributes-of-recorded-results"/>4.15.2.4 Naming and Attributes of Recorded Results<a class="headerlink" href="#sec:simple-modules:naming-and-attributes-of-recorded-results" title="Permalink to this headline">¶</a></h4>

<p>The names of recorded result items will be formed by concatenating the
statistic name and the recording mode with a colon between them:
<tt>"<i>&lt;statisticName&gt;</i>:<i>&lt;recordingMode&gt;</i>"</tt>.

<p>Thus, the following statistics

<pre class="ned">
@statistic[dropRate](source=count(drop)/count(pk); record=last,vector?);
@statistic[droppedBytes](source=packetBytes(pkdrop); record=sum,vector(sum)?);
</pre>
<p>
will produce the following scalars: <tt>dropRate:last</tt>, <tt>droppedBytes:sum</tt>,
and the following vectors: <tt>dropRate:vector</tt>, <tt>droppedBytes:vector(sum)</tt>.

<p>All property keys (except for <tt>record</tt>) are recorded as result
attributes into the vector file or scalar file. The <tt>title</tt> property
will be tweaked a little before recording: the recording mode will be added
after a comma, otherwise all result items saved from the same statistic
would have exactly the same name.

<p>Example: "Dropped Bytes, sum", "Dropped Bytes, vector(sum)"

<p>
It is allowed to use other property keys as well, but they won't be
interpreted by the OMNeT++ runtime or the result analysis tool.

<p>
<h4><a name="sec:simple-modules:statistic-source-and-record-details"/>4.15.2.5 Source and Record Expressions in Detail<a class="headerlink" href="#sec:simple-modules:statistic-source-and-record-details" title="Permalink to this headline">¶</a></h4>

<p>To fully understand <tt>source</tt> and <tt>record</tt>, it will be useful to see
how result recording is set up.

<p>When a module or channel is created in the simulation, the OMNeT++ runtime
examines the <tt>@statistic</tt> properties on its NED declaration, and adds
listeners on the signals they mention as input. There are two kinds of
listeners associated with result recording: <i>result filters</i> and
<i>result recorders</i>. Result filters can be chained, and at the end of
the chain there is always a recorder. So, there may be a recorder directly
subscribed to a signal, or there may be a chain of one or more filters plus
a recorder. Imagine it as a pipeline, or rather a &#8220;pipe tree&#8221;, where the
tree roots are signals, the leaves are result recorders, and the
intermediate nodes are result filters.

<p>Result filters typically perform some processing on the values they receive
on their inputs (the previous filter in the chain or directly a signal),
and propagate them to their output (chained filters and recorders). A
filter may also swallow (i.e. not propagate) values. Recorders may write
the received values into an output vector, or record output scalar(s)
at the end of the simulation.

<p>Many operations exist both in filter and recorder form. For example, the
<tt>sum</tt> <i>filter</i> propagates the sum of values received on its
input to its output; and the <tt>sum</tt> <i>recorder</i> only computes the
the sum of received values in order to record it as an output scalar on
simulation completion.

<p>The next figure illustrates which filters and recorders are created and how
they are connected for the following statistics:

<pre class="ned">
@statistic[droppedBits](source=8*packetBytes(pkdrop); record=sum,vector(sum));
</pre>
<p>

<p>  <center>
    <img src="statisticrecording.svg">
    <center><div class="caption"><i>Figure: Result filters and recorders chained</i></div></center>
  </center>

<p>
<ul class="hint"><b>HINT</b><br>
To see how result filters and recorders have been set up for a particular
simulation, run the simulation with the <b><tt>debug-statistics-recording</tt></b>
configuration option, e.g. specify <tt>--debug-statistics-recording=true</tt>
on the command line.
</ul>

<p>
<h3><a name="sec:simple-modules:statistic-recording-dynamic-signals"/>4.15.3 Statistics Recording for Dynamically Registered Signals<a class="headerlink" href="#sec:simple-modules:statistic-recording-dynamic-signals" title="Permalink to this headline">¶</a></h3>

<p>It is often convenient to have a module record statistics per session, per
connection, per client, etc. One way of handling this use case is registering
signals dynamically (e.g. <tt>session1-jitter</tt>, <tt>session2-jitter</tt>, ...),
and setting up <b><tt>@statistic</tt></b>-style result recording on each.

<p>The NED file would look like this:

<pre class="ned">
@signal[session*-jitter](type=simtime_t); // note the wildcard
@statisticTemplate[sessionJitter](record=mean,vector?);
</pre>
<p>
In the C++ code of the module, you need to register each new signal with
<tt>registerSignal()</tt>, and in addition, tell OMNeT++ to set up statistics
recording for it as described by the <b><tt>@statisticTemplate</tt></b> property.
The latter can be achieved by calling <tt>getEnvir()-&gt;addResultRecorders()</tt>.

<pre class="cpp">
char signalName[32];
sprintf(signalName, "session%d-jitter", sessionNum);
simsignal_t signal = registerSignal(signalName);

char statisticName[32];
sprintf(statisticName, "session%d-jitter", sessionNum);
<a href="../api/classomnetpp_1_1cProperty.html">cProperty</a> *statisticTemplate =
    getProperties()-&gt;get("statisticTemplate", "sessionJitter");
getEnvir()-&gt;addResultRecorders(this, signal, statisticName, statisticTemplate);
</pre>
<p>
In the <b><tt>@statisticTemplate</tt></b> property, the <tt>source</tt> key will be
ignored (because the signal given as parameter will be used as source). The
actual name and index of property will also be ignored. (With
<b><tt>@statistic</tt></b>, the index holds the result name, but here the name is
explicitly specified in the statisticName parameter.)

<p>When multiple signals are recorded using a common <b><tt>@statisticTemplate</tt></b>
property, you'll want the titles of the recorded statistics to differ
for each signal. This can be achieved by using dollar variables in the
<tt>title</tt> key of <b><tt>@statisticTemplate</tt></b>. The following variables
are available:

<p><ul>
  <li> <tt>$name</tt>: name of the statistic
  <li> <tt>$component</tt>: component fullpath
  <li> <tt>$mode</tt>: recording mode
  <li> <tt>$namePart[0-9]+</tt>: given part of statistic name, when split
    along colons (:); numbering starts with 1
</ul>

<p>For example, if the statistic name is <tt>"conn:host1-to-host4(3):bytesSent"</tt>,
and the title is <tt>"bytes sent in connection $namePart2"</tt>, it will become
<tt>"bytes sent in connection host1-to-host4(3)"</tt>.

<p>
<h3><a name="sec:simple-modules:statistic-recording-programmatically"/>4.15.4 Adding Result Filters and Recorders Programmatically<a class="headerlink" href="#sec:simple-modules:statistic-recording-programmatically" title="Permalink to this headline">¶</a></h3>

<p>As an alternative to <b><tt>@statisticTemplate</tt></b> and <tt>addResultRecorders()</tt>,
it is also possible to set up result recording programmatically, by creating and
attaching result filters and recorders to the desired signals.

<p><ul class="note"><b>NOTE</b><br>
It is important to know that <tt>@statistic</tt> implements warmup period 
support by including a special <i>warmup period filter</i> at the
front of the filter/recorder chain. When adding result filters and recorders
manually, you need to add this filter manually as well.
</ul>

<p>The following code example sets up recording to an output vector after
removing duplicate values, and is essentially equivalent to the following
<tt>@statistic</tt> line:

<pre class="ned">
@statistic[queueLength](source=qlen; record=vector(removeRepeats);
                        title="Queue Length"; unit=packets);
</pre>
<p>
The C++ code:

<pre class="cpp">
simsignal_t signal = registerSignal("qlen");

<a href="../api/classomnetpp_1_1cResultFilter.html">cResultFilter</a> *warmupFilter =
        <a href="../api/classomnetpp_1_1cResultFilterType.html">cResultFilterType</a>::get("warmup")-&gt;create();
<a href="../api/classomnetpp_1_1cResultFilter.html">cResultFilter</a> *removeRepeatsFilter = 
        <a href="../api/classomnetpp_1_1cResultFilterType.html">cResultFilterType</a>::get("removeRepeats")-&gt;create();
<a href="../api/classomnetpp_1_1cResultRecorder.html">cResultRecorder</a> *vectorRecorder = 
        <a href="../api/classomnetpp_1_1cResultRecorderType.html">cResultRecorderType</a>::get("vector")-&gt;create();
<a href="../api/classomnetpp_1_1opp__string__map.html">opp_string_map</a> *attrs = new <a href="../api/classomnetpp_1_1opp__string__map.html">opp_string_map</a>;
(*attrs)["title"] = "Queue Length";
(*attrs)["unit"] = "packets";
vectorRecorder-&gt;init(this, "queueLength", "vector", nullptr, attrs);

subscribe(signal, warmupFilter);
warmupFilter-&gt;addDelegate(removeRepeatsFilter);
removeRepeatsFilter-&gt;addDelegate(vectorRecorder);
</pre>
<p>

<p><h3><a name="sec:simple-modules:emitting-statistic-signals"/>4.15.5 Emitting Signals<a class="headerlink" href="#sec:simple-modules:emitting-statistic-signals" title="Permalink to this headline">¶</a></h3>

<p>Emitting signals for statistical purposes does not differ much from
emitting signals for any other purpose. Statistic signals are primarily
expected to contain numeric values, so the overloaded <tt>emit()</tt> functions
that take <tt>long</tt>, <tt>double</tt> and <tt>simtime_t</tt> are going to be the
most useful ones.

<p><b>Emitting with timestamp.</b> The emitted values are associated with
the current simulation time. At times it might be desirable to associate
them with a different timestamp, in much the same way as the
<tt>recordWithTimestamp()</tt> method of <tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> (see
<a href="chap7.html#sec:sim-lib:coutvector">[7.9.1]</a>) does. For example, assume that you want to
emit a signal at the start of every successful wireless frame reception.
However, whether any given frame reception is going to be successful can
only be known after the reception has completed. Hence, values can only be
emitted at reception completion, and need to be associated with past
timestamps.

<p>To emit a value with a different timestamp, an object containing
a <i>(timestamp, value)</i> pair needs to be filled in, and emitted using
the <tt>emit(simsignal_t, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *)</tt> method. The class is called
<tt><a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a></tt>, and it simply has two public data members called
<tt>time</tt> and <tt>value</tt>, with types <tt>simtime_t</tt> and <tt>double</tt>.
It also has a convenience constructor taking these two values.

<p><ul class="note"><b>NOTE</b><br>
<tt><a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a></tt> is not part of the signal mechanism. Instead,
the result recording listeners provided by OMNeT++ have been written
in a way so that they understand <tt><a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a></tt>, and know how
to handle it.
</ul>

<p>An example usage:

<pre class="cpp">
simtime_t frameReceptionStartTime = ...;
double receivePower = ...;
<a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a> tmp(frameReceptionStartTime, receivePower);
emit(recvPowerSignal, &tmp);
</pre>
<p>
If performance is critical, the <tt><a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a></tt> object may be
made a class member or a static variable to eliminate object
construction/destruction time.<br><ul><font size=-1>[It is safe to use a static
variable here because the simulation program is single-threaded,
but ensure that there isn't a listener somewhere that would modify
the same static variable during firing.]</font></ul>

<p>Timestamps must be monotonically increasing.

<p><b>Emitting non-numeric values.</b> Sometimes it is practical to have
multi-purpose signals, or to retrofit an existing non-statistical signal so
that it can be recorded as a result. For this reason, signals having
non-numeric types (that is, <tt>const char *</tt> and <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a> *</tt>) may
also be recorded as results. Wherever such values need to be interpreted as
numbers, the following rules are used by the built-in result recording
listeners:

<p><ul>
  <li> Strings are recorded as 1.0, except for <tt>nullptr</tt> which is recorded as 0.0;
  <li> Objects that can be cast to <tt><a href="../api/classomnetpp_1_1cITimestampedValue.html">cITimestampedValue</a></tt> are recorded
     using the <tt>getSignalTime()</tt> and <tt>getSignalValue()</tt>
     methods of the class;
  <li> Other objects are recorded as 1.0, except for <tt>nullptr</tt> which is recorded as 0.0.
</ul>

<p><tt><a href="../api/classomnetpp_1_1cITimestampedValue.html">cITimestampedValue</a></tt> is a C++ interface that may be used as an additional
base class for any class. It is declared like this:

<pre class="cpp">
class <a href="../api/classomnetpp_1_1cITimestampedValue.html">cITimestampedValue</a> {
    public:
        virtual ~<a href="../api/classomnetpp_1_1cITimestampedValue.html">cITimestampedValue</a>() {}
        virtual double getSignalValue(simsignal_t signalID) = 0;
        virtual simtime_t getSignalTime(simsignal_t signalID);
};
</pre>
<p>
<tt>getSignalValue()</tt> is pure virtual (it must return some value),
but <tt>getSignalTime()</tt> has a default implementation that
returns the current simulation time. Note the <tt>signalID</tt> argument
that allows the same class to serve multiple signals (i.e. to return
different values for each).

<p>
<h3><a name="sec:simple-modules:writing-result-filters"/>4.15.6 Writing Result Filters and Recorders<a class="headerlink" href="#sec:simple-modules:writing-result-filters" title="Permalink to this headline">¶</a></h3>

<p>You can define your own result filters and recorders in addition to the
built-in ones. Similar to defining modules and new NED functions, you have
to write the implementation in C++, and then register it with a
registration macro to let OMNeT++ know about it. The new result filter or
recorder can then be used in the <tt>source=</tt> and <tt>record=</tt> attributes
of <b><tt>@statistic</tt></b> properties just like the built-in ones.

<p>Result filters must be subclassed from <tt><a href="../api/classomnetpp_1_1cResultFilter.html">cResultFilter</a></tt> or from one
of its more specific subclasses <tt><a href="../api/classomnetpp_1_1cNumericResultFilter.html">cNumericResultFilter</a></tt> and
<tt><a href="../api/classomnetpp_1_1cObjectResultFilter.html">cObjectResultFilter</a></tt>. The new result filter class needs to be
registered using the <tt>Register_ResultFilter(NAME, CLASSNAME)</tt> macro.

<p>Similarly, a result recorder must subclass from the
<tt><a href="../api/classomnetpp_1_1cResultRecorder.html">cResultRecorder</a></tt> or the more specific
<tt><a href="../api/classomnetpp_1_1cNumericResultRecorder.html">cNumericResultRecorder</a></tt> class, and be registered using the
<tt>Register_ResultRecorder(NAME, CLASSNAME)</tt> macro.

<p>
  <center>
    <img src="resultlistener-inheritance.svg">
    <center><div class="caption"><i>Figure: Inheritance of result filter and recorder classes</i></div></center>
  </center>

<p>
An example result filter implementation from the simulation runtime:

<p>
<pre class="cpp">
/**
 * Filter that outputs the sum of signal values divided by the measurement
 * interval (simtime minus warmup period).
 */
class <a href="../api/classomnetpp_1_1SumPerDurationFilter.html">SumPerDurationFilter</a> : public <a href="../api/classomnetpp_1_1cNumericResultFilter.html">cNumericResultFilter</a>
{
    protected:
        double sum;
    protected:
        virtual bool process(simtime_t& t, double& value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details);
    public:
        <a href="../api/classomnetpp_1_1SumPerDurationFilter.html">SumPerDurationFilter</a>() {sum = 0;}
};

Register_ResultFilter("sumPerDuration", <a href="../api/classomnetpp_1_1SumPerDurationFilter.html">SumPerDurationFilter</a>);

bool <a href="../api/classomnetpp_1_1SumPerDurationFilter.html">SumPerDurationFilter</a>::process(simtime_t& t, double& value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *)
{
    sum += value;
    value = sum / (simTime() - getSimulation()-&gt;getWarmupPeriod());
    return true;
}
</pre>

<p>


<hr class='pgbr'><p><hr><b><a href="chap3.html">[Prev]</A>&nbsp;<a href="chap5.html">[Next]</A>&nbsp;<a href="toc.html#toc_4.">[TOC]</a>&nbsp;<a href="usman.html">[Chapters]</a></b><hr></p>

</body>
</html>
