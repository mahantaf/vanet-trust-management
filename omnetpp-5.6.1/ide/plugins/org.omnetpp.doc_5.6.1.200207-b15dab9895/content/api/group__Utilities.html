<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OMNeT++ Simulation Library: Utility Classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMNeT++ Simulation Library
   &#160;<span id="projectnumber">5.6.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Utilities.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility Classes</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This group is a collection of classes and functions that make it easier to write simulation models. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cMatchExpression_1_1Matchable.html">cMatchExpression::Matchable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects to be matched must implement this interface.  <a href="classomnetpp_1_1cMatchExpression_1_1Matchable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cMatchExpression.html">cMatchExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether an object matches an expression.  <a href="classomnetpp_1_1cMatchExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cMatchableString.html">cMatchableString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to make a string matchable with <a class="el" href="classomnetpp_1_1cMatchExpression.html" title="Decides whether an object matches an expression. ">cMatchExpression</a>.  <a href="classomnetpp_1_1cMatchableString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Glob-style pattern matching class, adopted to special OMNeT++ requirements. One instance represents a pattern to match.  <a href="classomnetpp_1_1cPatternMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String tokenizer class, modelled after strtok().  <a href="classomnetpp_1_1cStringTokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cTopology.html">cTopology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routing support. The <a class="el" href="classomnetpp_1_1cTopology.html" title="Routing support. The cTopology class was designed primarily to support routing in telecommunication o...">cTopology</a> class was designed primarily to support routing in telecommunication or multiprocessor networks.  <a href="classomnetpp_1_1cTopology.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1opp__string.html">opp_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight string class, used internally in some parts of OMNeT++.  <a href="classomnetpp_1_1opp__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1opp__string__vector.html">opp_string_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight string vector, used internally in some parts of OMNeT++.  <a href="classomnetpp_1_1opp__string__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1opp__string__map.html">opp_string_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight string-to-string map, used internally in some parts of OMNeT++.  <a href="classomnetpp_1_1opp__string__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5044f74639a1f5cd3701d438261a0407"><td class="memTemplParams" colspan="2">template&lt;class P , class T &gt; </td></tr>
<tr class="memitem:ga5044f74639a1f5cd3701d438261a0407"><td class="memTemplItemLeft" align="right" valign="top">P&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga5044f74639a1f5cd3701d438261a0407">check_and_cast</a> (T *p)</td></tr>
<tr class="memdesc:ga5044f74639a1f5cd3701d438261a0407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a pointer to the given pointer type P, and throw exception if fails.  <a href="group__Utilities.html#ga5044f74639a1f5cd3701d438261a0407">More...</a><br /></td></tr>
<tr class="separator:ga5044f74639a1f5cd3701d438261a0407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4782d0f87609e981435a9ac0c0fcb0"><td class="memTemplParams" colspan="2">template&lt;class P , class T &gt; </td></tr>
<tr class="memitem:ga0b4782d0f87609e981435a9ac0c0fcb0"><td class="memTemplItemLeft" align="right" valign="top">P&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0b4782d0f87609e981435a9ac0c0fcb0">check_and_cast_nullable</a> (T *p)</td></tr>
<tr class="memdesc:ga0b4782d0f87609e981435a9ac0c0fcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of check_and_cast&lt;&gt;() that also allows nullptr as input.  <a href="group__Utilities.html#ga0b4782d0f87609e981435a9ac0c0fcb0">More...</a><br /></td></tr>
<tr class="separator:ga0b4782d0f87609e981435a9ac0c0fcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1513afb661c828b08c376cd0b753267"><td class="memTemplParams" colspan="2">template&lt;typename ToInt , typename FromInt &gt; </td></tr>
<tr class="memitem:gaa1513afb661c828b08c376cd0b753267"><td class="memTemplItemLeft" align="right" valign="top">ToInt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa1513afb661c828b08c376cd0b753267">checked_int_cast</a> (FromInt x, const char *errmsg=nullptr)</td></tr>
<tr class="memdesc:gaa1513afb661c828b08c376cd0b753267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The context argument will be used for the error message.  <a href="group__Utilities.html#gaa1513afb661c828b08c376cd0b753267">More...</a><br /></td></tr>
<tr class="separator:gaa1513afb661c828b08c376cd0b753267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab96ebab99c3498b3df027cad31d1d27"><td class="memTemplParams" colspan="2">template&lt;typename ToInt , typename FromInt &gt; </td></tr>
<tr class="memitem:gaab96ebab99c3498b3df027cad31d1d27"><td class="memTemplItemLeft" align="right" valign="top">ToInt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaab96ebab99c3498b3df027cad31d1d27">checked_int_cast</a> (FromInt x, const <a class="el" href="classomnetpp_1_1cObject.html">cObject</a> *context, const char *errmsg=nullptr)</td></tr>
<tr class="memdesc:gaab96ebab99c3498b3df027cad31d1d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The context argument will be used for the error message.  <a href="group__Utilities.html#gaab96ebab99c3498b3df027cad31d1d27">More...</a><br /></td></tr>
<tr class="separator:gaab96ebab99c3498b3df027cad31d1d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee410c4efb62be0d078da9fa0a15c91"><td class="memTemplParams" colspan="2">template&lt;typename ToInt &gt; </td></tr>
<tr class="memitem:ga6ee410c4efb62be0d078da9fa0a15c91"><td class="memTemplItemLeft" align="right" valign="top">ToInt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga6ee410c4efb62be0d078da9fa0a15c91">checked_int_cast</a> (double d, const char *errmsg=nullptr)</td></tr>
<tr class="memdesc:ga6ee410c4efb62be0d078da9fa0a15c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The context argument will be used for the error message.  <a href="group__Utilities.html#ga6ee410c4efb62be0d078da9fa0a15c91">More...</a><br /></td></tr>
<tr class="separator:ga6ee410c4efb62be0d078da9fa0a15c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b35bf42f5261c56fb5c0cade0f05ea7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga5b35bf42f5261c56fb5c0cade0f05ea7">opp_strlen</a> (const char *)</td></tr>
<tr class="memdesc:ga5b35bf42f5261c56fb5c0cade0f05ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the standard strlen() function, except that it also accepts nullptr and returns 0 for it.  <a href="group__Utilities.html#ga5b35bf42f5261c56fb5c0cade0f05ea7">More...</a><br /></td></tr>
<tr class="separator:ga5b35bf42f5261c56fb5c0cade0f05ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff9851aa2bc996cca97b20b81e5ab80"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga2ff9851aa2bc996cca97b20b81e5ab80">opp_strdup</a> (const char *)</td></tr>
<tr class="memdesc:ga2ff9851aa2bc996cca97b20b81e5ab80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates the string, using <code>new char[]</code>. For nullptr and empty strings it returns nullptr.  <a href="group__Utilities.html#ga2ff9851aa2bc996cca97b20b81e5ab80">More...</a><br /></td></tr>
<tr class="separator:ga2ff9851aa2bc996cca97b20b81e5ab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad904f75ebf7debc890f5f2bcf75e79df"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad904f75ebf7debc890f5f2bcf75e79df">opp_strcpy</a> (char *, const char *)</td></tr>
<tr class="memdesc:gad904f75ebf7debc890f5f2bcf75e79df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the standard strcpy() function, except that nullptr as the second argument is treated as an empty string ("").  <a href="group__Utilities.html#gad904f75ebf7debc890f5f2bcf75e79df">More...</a><br /></td></tr>
<tr class="separator:gad904f75ebf7debc890f5f2bcf75e79df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca723c5e22d4626cd50158df8a0ea302"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaca723c5e22d4626cd50158df8a0ea302">opp_strcmp</a> (const char *, const char *)</td></tr>
<tr class="memdesc:gaca723c5e22d4626cd50158df8a0ea302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the standard strcmp() function, except that nullptr is treated exactly as an empty string ("").  <a href="group__Utilities.html#gaca723c5e22d4626cd50158df8a0ea302">More...</a><br /></td></tr>
<tr class="separator:gaca723c5e22d4626cd50158df8a0ea302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46437ddb528048851ff78a55fda7fd0b"><td class="memItemLeft" align="right" valign="top">SIM_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga46437ddb528048851ff78a55fda7fd0b">opp_strprettytrunc</a> (char *dest, const char *src, unsigned maxlen)</td></tr>
<tr class="memdesc:ga46437ddb528048851ff78a55fda7fd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies src string into dest, and if its length would exceed maxlen, it is truncated with an ellipsis. For example, <code>opp_strprettytrunc(buf, "long-long",6)</code> yields <code>"lon..."</code>.  <a href="group__Utilities.html#ga46437ddb528048851ff78a55fda7fd0b">More...</a><br /></td></tr>
<tr class="separator:ga46437ddb528048851ff78a55fda7fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ab2b6c42da31388031dc4c8b7e34b8"><td class="memItemLeft" align="right" valign="top">SIM_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad2ab2b6c42da31388031dc4c8b7e34b8">opp_typename</a> (const std::type_info &amp;t)</td></tr>
<tr class="memdesc:gad2ab2b6c42da31388031dc4c8b7e34b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a C++ type, correcting the quirks of various compilers.  <a href="group__Utilities.html#gad2ab2b6c42da31388031dc4c8b7e34b8">More...</a><br /></td></tr>
<tr class="separator:gad2ab2b6c42da31388031dc4c8b7e34b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699107b48aeac4f768b6edf9d4b7b1b5"><td class="memItemLeft" align="right" valign="top">SIM_API int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga699107b48aeac4f768b6edf9d4b7b1b5">opp_get_monotonic_clock_nsecs</a> ()</td></tr>
<tr class="memdesc:ga699107b48aeac4f768b6edf9d4b7b1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a monotonic time in nanoseconds since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g. if the system administrator manually changes the clock). Note that the actual resolution (precision) of the clock may be less than nanoseconds.  <a href="group__Utilities.html#ga699107b48aeac4f768b6edf9d4b7b1b5">More...</a><br /></td></tr>
<tr class="separator:ga699107b48aeac4f768b6edf9d4b7b1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891c0be14175481589952eda25a9607f"><td class="memItemLeft" align="right" valign="top">SIM_API int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga891c0be14175481589952eda25a9607f">opp_get_monotonic_clock_usecs</a> ()</td></tr>
<tr class="memdesc:ga891c0be14175481589952eda25a9607f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a monotonic time in microseconds since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g. if the system administrator manually changes the clock). Note that the actual resolution (precision) of the clock may be less than microseconds.  <a href="group__Utilities.html#ga891c0be14175481589952eda25a9607f">More...</a><br /></td></tr>
<tr class="separator:ga891c0be14175481589952eda25a9607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5044f74639a1f5cd3701d438261a0407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5044f74639a1f5cd3701d438261a0407">&#9670;&nbsp;</a></span>check_and_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">P omnetpp::check_and_cast </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast a pointer to the given pointer type P, and throw exception if fails. </p>
<p>The method calls dynamic_cast&lt;P&gt;(p) where P is a type you supplied; if the result is nullptr (which indicates incompatible types), an exception is thrown.</p>
<p>In the following example, DHCPPacket is a subclass of <a class="el" href="classomnetpp_1_1cMessage.html" title="The message class in OMNeT++. cMessage objects may represent events, messages, jobs or other entities...">cMessage</a>, and we want to assert that the message received is actually a DHCPPacket. If not, the simulation stops with an error message as the result of the exception. </p><pre>
  <a class="el" href="classomnetpp_1_1cMessage.html" title="The message class in OMNeT++. cMessage objects may represent events, messages, jobs or other entities...">cMessage</a> *msg = ...;
  DHCPPacket *pk = check_and_cast&lt;DHCPPacket *&gt;(msg);
</pre> 
<p class="reference">References <a class="el" href="group__Utilities.html#gad2ab2b6c42da31388031dc4c8b7e34b8">omnetpp::opp_typename()</a>.</p>

</div>
</div>
<a id="ga0b4782d0f87609e981435a9ac0c0fcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4782d0f87609e981435a9ac0c0fcb0">&#9670;&nbsp;</a></span>check_and_cast_nullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">P omnetpp::check_and_cast_nullable </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variant of check_and_cast&lt;&gt;() that also allows nullptr as input. </p>

</div>
</div>
<a id="gaa1513afb661c828b08c376cd0b753267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1513afb661c828b08c376cd0b753267">&#9670;&nbsp;</a></span>checked_int_cast() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ToInt omnetpp::checked_int_cast </td>
          <td>(</td>
          <td class="paramtype">FromInt&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The context argument will be used for the error message. </p>

<p class="reference">Referenced by <a class="el" href="classomnetpp_1_1cNedValue.html#a561b4a60cc640710c3b9220d692de07d">cNedValue::operator char()</a>, <a class="el" href="classomnetpp_1_1cPar.html#a561b4a60cc640710c3b9220d692de07d">cPar::operator char()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#a48d27bd92e68c69527589ea65a9af69f">cNedValue::operator int()</a>, <a class="el" href="classomnetpp_1_1cPar.html#a48d27bd92e68c69527589ea65a9af69f">cPar::operator int()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#ad7ce59321a0dd63e7f1fab6dceabe53b">cNedValue::operator long()</a>, <a class="el" href="classomnetpp_1_1cPar.html#ad7ce59321a0dd63e7f1fab6dceabe53b">cPar::operator long()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#aa83077b8f499dae99948d972af2dc8c6">cNedValue::operator long long()</a>, <a class="el" href="classomnetpp_1_1cPar.html#aa83077b8f499dae99948d972af2dc8c6">cPar::operator long long()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#a11840cd2d3ee7968aaf9b04a0af3bec0">cNedValue::operator short()</a>, <a class="el" href="classomnetpp_1_1cPar.html#a11840cd2d3ee7968aaf9b04a0af3bec0">cPar::operator short()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#a891f3d5b152d0bd0b8bc27726d45a491">cNedValue::operator unsigned char()</a>, <a class="el" href="classomnetpp_1_1cPar.html#a891f3d5b152d0bd0b8bc27726d45a491">cPar::operator unsigned char()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#ab85cf3d18c4ed830e687b87ede9e40a0">cNedValue::operator unsigned int()</a>, <a class="el" href="classomnetpp_1_1cPar.html#ab85cf3d18c4ed830e687b87ede9e40a0">cPar::operator unsigned int()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#acafb5c7caec25508a24cb4800beb18f9">cNedValue::operator unsigned long()</a>, <a class="el" href="classomnetpp_1_1cPar.html#acafb5c7caec25508a24cb4800beb18f9">cPar::operator unsigned long()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#a3a81249f06665fa9c35153447216b96d">cNedValue::operator unsigned long long()</a>, <a class="el" href="classomnetpp_1_1cPar.html#a3a81249f06665fa9c35153447216b96d">cPar::operator unsigned long long()</a>, <a class="el" href="classomnetpp_1_1cNedValue.html#a6207df99f12600860d669651bdef19a2">cNedValue::operator unsigned short()</a>, <a class="el" href="classomnetpp_1_1cPar.html#a6207df99f12600860d669651bdef19a2">cPar::operator unsigned short()</a>, and <a class="el" href="classomnetpp_1_1cNedValue.html#ae8f1aa35fe9287f1c2179e086c5243e7">cNedValue::operator=()</a>.</p>

</div>
</div>
<a id="gaab96ebab99c3498b3df027cad31d1d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab96ebab99c3498b3df027cad31d1d27">&#9670;&nbsp;</a></span>checked_int_cast() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ToInt omnetpp::checked_int_cast </td>
          <td>(</td>
          <td class="paramtype">FromInt&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classomnetpp_1_1cObject.html">cObject</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The context argument will be used for the error message. </p>

</div>
</div>
<a id="ga6ee410c4efb62be0d078da9fa0a15c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ee410c4efb62be0d078da9fa0a15c91">&#9670;&nbsp;</a></span>checked_int_cast() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ToInt omnetpp::checked_int_cast </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The context argument will be used for the error message. </p>

</div>
</div>
<a id="ga5b35bf42f5261c56fb5c0cade0f05ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b35bf42f5261c56fb5c0cade0f05ea7">&#9670;&nbsp;</a></span>opp_strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int opp_strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the standard strlen() function, except that it also accepts nullptr and returns 0 for it. </p>

</div>
</div>
<a id="ga2ff9851aa2bc996cca97b20b81e5ab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ff9851aa2bc996cca97b20b81e5ab80">&#9670;&nbsp;</a></span>opp_strdup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * opp_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates the string, using <code>new char[]</code>. For nullptr and empty strings it returns nullptr. </p>

<p class="reference">Referenced by <a class="el" href="classomnetpp_1_1opp__string.html#a84534ecb0bfb413a88ed782fa2cdfaf6">opp_string::operator=()</a>, and <a class="el" href="classomnetpp_1_1opp__string.html#a4242ceb0bdc72550ef4bcf02f1682df5">opp_string::opp_string()</a>.</p>

</div>
</div>
<a id="gad904f75ebf7debc890f5f2bcf75e79df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad904f75ebf7debc890f5f2bcf75e79df">&#9670;&nbsp;</a></span>opp_strcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * opp_strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the standard strcpy() function, except that nullptr as the second argument is treated as an empty string (""). </p>

</div>
</div>
<a id="gaca723c5e22d4626cd50158df8a0ea302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca723c5e22d4626cd50158df8a0ea302">&#9670;&nbsp;</a></span>opp_strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int opp_strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the standard strcmp() function, except that nullptr is treated exactly as an empty string (""). </p>

<p class="reference">Referenced by <a class="el" href="classomnetpp_1_1cObject.html#a3666b57e313a2f38433fdfc50fd94a6b">cObject::isName()</a>, <a class="el" href="classomnetpp_1_1opp__string.html#a39a932f2ac073af31ffdb2c7469c2ed8">opp_string::operator!=()</a>, <a class="el" href="classomnetpp_1_1opp__string.html#a532a46694e54c770fd734fec962e3c19">opp_string::operator&lt;()</a>, and <a class="el" href="classomnetpp_1_1opp__string.html#ae3202a6e72d5cc6568d871b1b7a06bc6">opp_string::operator==()</a>.</p>

</div>
</div>
<a id="ga46437ddb528048851ff78a55fda7fd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46437ddb528048851ff78a55fda7fd0b">&#9670;&nbsp;</a></span>opp_strprettytrunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API char* omnetpp::opp_strprettytrunc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies src string into dest, and if its length would exceed maxlen, it is truncated with an ellipsis. For example, <code>opp_strprettytrunc(buf, "long-long",6)</code> yields <code>"lon..."</code>. </p>

</div>
</div>
<a id="gad2ab2b6c42da31388031dc4c8b7e34b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2ab2b6c42da31388031dc4c8b7e34b8">&#9670;&nbsp;</a></span>opp_typename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API const char* omnetpp::opp_typename </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of a C++ type, correcting the quirks of various compilers. </p>

<p class="reference">Referenced by <a class="el" href="group__Utilities.html#ga5044f74639a1f5cd3701d438261a0407">omnetpp::check_and_cast()</a>, <a class="el" href="classomnetpp_1_1cGenericReadonlyWatch.html#aa0d8ddf8e340589ce5a4ebdc1d5e070d">cGenericReadonlyWatch&lt; T &gt;::getClassName()</a>, and <a class="el" href="classomnetpp_1_1cGenericAssignableWatch.html#aa0d8ddf8e340589ce5a4ebdc1d5e070d">cGenericAssignableWatch&lt; T &gt;::getClassName()</a>.</p>

</div>
</div>
<a id="ga699107b48aeac4f768b6edf9d4b7b1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga699107b48aeac4f768b6edf9d4b7b1b5">&#9670;&nbsp;</a></span>opp_get_monotonic_clock_nsecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API int64_t omnetpp::opp_get_monotonic_clock_nsecs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a monotonic time in nanoseconds since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g. if the system administrator manually changes the clock). Note that the actual resolution (precision) of the clock may be less than nanoseconds. </p>

</div>
</div>
<a id="ga891c0be14175481589952eda25a9607f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga891c0be14175481589952eda25a9607f">&#9670;&nbsp;</a></span>opp_get_monotonic_clock_usecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API int64_t omnetpp::opp_get_monotonic_clock_usecs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a monotonic time in microseconds since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g. if the system administrator manually changes the clock). Note that the actual resolution (precision) of the clock may be less than microseconds. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Feb 7 2020 11:37:56 for OMNeT++ Simulation Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
